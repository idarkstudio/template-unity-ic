import {
  Actor,
  AnonymousIdentity,
  HttpAgent,
  polling_exports
} from "./chunk-URGKDOGW.js";
import "./chunk-T72XF2C6.js";
import "./chunk-FQEILFST.js";
import "./chunk-ZZWAN6H4.js";
import {
  Principal
} from "./chunk-LAA32PSZ.js";
import {
  __publicField
} from "./chunk-7QAK3AHL.js";

// node_modules/@dfinity/nns/dist/esm/chunk-ZMUQLPST.js
var N = Principal.fromText("rrkah-fqaaa-aaaaa-aaaaq-cai");
var E = Principal.fromText("rrkah-fqaaa-aaaaa-aaaaq-cai");
var o = Principal.fromText("ryjl3-tyaaa-aaaaa-aaaba-cai");
var t = Principal.fromText("renrk-eyaaa-aaaaa-aaada-cai");
var _ = Principal.fromText("r7inp-6aaaa-aaaaa-aaabq-cai");

// node_modules/@dfinity/utils/dist/esm/index.js
var A = ((r) => (r[r.FractionalMoreThan8Decimals = 0] = "FractionalMoreThan8Decimals", r[r.InvalidFormat = 1] = "InvalidFormat", r))(A || {});
var T = BigInt(1e8);
var k = (t3) => {
  let e2 = t3.includes("e") ? Number(t3).toLocaleString("en", { useGrouping: false, maximumFractionDigits: 20 }) : t3;
  e2 = e2.trim().replace(/[,']/g, "");
  let r = e2.match(/\d*(\.\d*)?/);
  if (!r || r[0] !== e2)
    return 1;
  let [n2, o5] = e2.split("."), i2 = BigInt(0);
  if (n2)
    try {
      i2 += BigInt(n2) * T;
    } catch {
      return 1;
    }
  if (o5) {
    if (o5.length > 8)
      return 0;
    try {
      i2 += BigInt(o5.padEnd(8, "0"));
    } catch {
      return 1;
    }
  }
  return i2;
};
var $ = { symbol: "ICP", name: "Internet Computer" };
var h = () => new HttpAgent({ host: "https://ic0.app", identity: new AnonymousIdentity() });
var X = ({ options: { canisterId: t3, serviceOverride: e2, certifiedServiceOverride: r, agent: n2, callTransform: o5, queryTransform: i2 }, idlFactory: x2, certifiedIdlFactory: a }) => {
  let u3 = n2 ?? h(), O = e2 ?? Actor.createActor(x2, { agent: u3, canisterId: t3, callTransform: o5, queryTransform: i2 }), R = r ?? Actor.createActor(a, { agent: u3, canisterId: t3, callTransform: o5, queryTransform: i2 });
  return { service: O, certifiedService: R, agent: u3, canisterId: t3 };
};
var p = class extends Error {
};
var m = class extends Error {
};
var s = (t3, e2) => {
  if (t3 == null)
    throw new m(e2);
};
var ee = (t3) => {
  if (t3 < 0 || t3 > 100)
    throw new p(`${t3} is not a valid percentage number.`);
};
var ne = (t3) => {
  let e2 = new DataView(t3.buffer, t3.byteOffset, t3.byteLength);
  if (typeof e2.getBigUint64 == "function")
    return e2.getBigUint64(0);
  {
    let r = BigInt(e2.getUint32(0)), n2 = BigInt(e2.getUint32(4));
    return (r << BigInt(32)) + n2;
  }
};
var ae = (t3) => new Uint8Array(t3);
var ce = (t3) => Array.from(t3);
var xe = (t3) => new Uint8Array(t3);
var se = (t3) => Array.from(t3).map((e2) => e2.charCodeAt(0));
var fe = (t3) => t3.reduce((e2, r) => e2 + r.toString(16).padStart(2, "0"), "");
var b = "abcdefghijklmnopqrstuvwxyz234567";
var d = /* @__PURE__ */ Object.create(null);
for (let t3 = 0; t3 < b.length; t3++)
  d[b[t3]] = t3;
d[0] = d.o;
d[1] = d.i;
var P = new Uint32Array([0, 1996959894, 3993919788, 2567524794, 124634137, 1886057615, 3915621685, 2657392035, 249268274, 2044508324, 3772115230, 2547177864, 162941995, 2125561021, 3887607047, 2428444049, 498536548, 1789927666, 4089016648, 2227061214, 450548861, 1843258603, 4107580753, 2211677639, 325883990, 1684777152, 4251122042, 2321926636, 335633487, 1661365465, 4195302755, 2366115317, 997073096, 1281953886, 3579855332, 2724688242, 1006888145, 1258607687, 3524101629, 2768942443, 901097722, 1119000684, 3686517206, 2898065728, 853044451, 1172266101, 3705015759, 2882616665, 651767980, 1373503546, 3369554304, 3218104598, 565507253, 1454621731, 3485111705, 3099436303, 671266974, 1594198024, 3322730930, 2970347812, 795835527, 1483230225, 3244367275, 3060149565, 1994146192, 31158534, 2563907772, 4023717930, 1907459465, 112637215, 2680153253, 3904427059, 2013776290, 251722036, 2517215374, 3775830040, 2137656763, 141376813, 2439277719, 3865271297, 1802195444, 476864866, 2238001368, 4066508878, 1812370925, 453092731, 2181625025, 4111451223, 1706088902, 314042704, 2344532202, 4240017532, 1658658271, 366619977, 2362670323, 4224994405, 1303535960, 984961486, 2747007092, 3569037538, 1256170817, 1037604311, 2765210733, 3554079995, 1131014506, 879679996, 2909243462, 3663771856, 1141124467, 855842277, 2852801631, 3708648649, 1342533948, 654459306, 3188396048, 3373015174, 1466479909, 544179635, 3110523913, 3462522015, 1591671054, 702138776, 2966460450, 3352799412, 1504918807, 783551873, 3082640443, 3233442989, 3988292384, 2596254646, 62317068, 1957810842, 3939845945, 2647816111, 81470997, 1943803523, 3814918930, 2489596804, 225274430, 2053790376, 3826175755, 2466906013, 167816743, 2097651377, 4027552580, 2265490386, 503444072, 1762050814, 4150417245, 2154129355, 426522225, 1852507879, 4275313526, 2312317920, 282753626, 1742555852, 4189708143, 2394877945, 397917763, 1622183637, 3604390888, 2714866558, 953729732, 1340076626, 3518719985, 2797360999, 1068828381, 1219638859, 3624741850, 2936675148, 906185462, 1090812512, 3747672003, 2825379669, 829329135, 1181335161, 3412177804, 3160834842, 628085408, 1382605366, 3423369109, 3138078467, 570562233, 1426400815, 3317316542, 2998733608, 733239954, 1555261956, 3268935591, 3050360625, 752459403, 1541320221, 2607071920, 3965973030, 1969922972, 40735498, 2617837225, 3943577151, 1913087877, 83908371, 2512341634, 3803740692, 2075208622, 213261112, 2463272603, 3855990285, 2094854071, 198958881, 2262029012, 4057260610, 1759359992, 534414190, 2176718541, 4139329115, 1873836001, 414664567, 2282248934, 4279200368, 1711684554, 285281116, 2405801727, 4167216745, 1634467795, 376229701, 2685067896, 3608007406, 1308918612, 956543938, 2808555105, 3495958263, 1231636301, 1047427035, 2932959818, 3654703836, 1088359270, 936918e3, 2847714899, 3736837829, 1202900863, 817233897, 3183342108, 3401237130, 1404277552, 615818150, 3134207493, 3453421203, 1423857449, 601450431, 3009837614, 3294710456, 1567103746, 711928724, 3020668471, 3272380065, 1510334235, 755167117]);
var L = (t3) => {
  let e2 = -1;
  for (let r = 0; r < t3.length; r++) {
    let o5 = (t3[r] ^ e2) & 255;
    e2 = P[o5] ^ e2 >>> 8;
  }
  return (e2 ^ -1) >>> 0;
};
var ye = (t3) => {
  let e2 = new ArrayBuffer(4);
  return new DataView(e2).setUint32(0, L(t3), false), new Uint8Array(e2);
};
var Y = (t3) => t3 == null;
var c = (t3) => !Y(t3);
var we = (t3) => c(t3) ? [t3] : [];
var K = (t3) => t3 == null ? void 0 : t3[0];
var Be = (t3) => {
  let e2 = K(t3);
  return s(e2), e2;
};

// node_modules/@dfinity/nns/dist/esm/chunk-3VPA6D46.js
var u = ({ IDL: e2 }) => {
  let t3 = e2.Record({ id: e2.Nat64 }), r = e2.Variant({ Ok: e2.Vec(t3), Err: e2.Text }), n2 = e2.Variant({ Ok: e2.Null, Err: e2.Text }), o5 = e2.Record({ error: e2.Opt(e2.Text), timestamp_seconds: e2.Nat64, neuron_id: e2.Opt(t3) }), a = e2.Record({ authenticated_principal_id: e2.Opt(e2.Principal), successfully_transferred_neurons: e2.Vec(o5), is_whitelisted_for_forwarding: e2.Bool, has_donated: e2.Bool, failed_transferred_neurons: e2.Vec(o5), neuron_ids: e2.Vec(t3), has_claimed: e2.Bool, has_forwarded: e2.Bool, icpts: e2.Nat32 }), i2 = e2.Variant({ Ok: a, Err: e2.Text });
  return e2.Service({ balance: e2.Func([e2.Text], [e2.Nat32], []), claim_neurons: e2.Func([e2.Text], [r], []), donate_account: e2.Func([e2.Text], [n2], []), forward_whitelisted_unclaimed_accounts: e2.Func([e2.Null], [n2], []), get_account: e2.Func([e2.Text], [i2], []), get_build_metadata: e2.Func([], [e2.Text], []), len: e2.Func([], [e2.Nat16], []), total: e2.Func([], [e2.Nat32], []) });
};
var d2 = ({ IDL: e2 }) => {
  let t3 = e2.Record({ id: e2.Nat64 }), r = e2.Variant({ Ok: e2.Vec(t3), Err: e2.Text }), n2 = e2.Variant({ Ok: e2.Null, Err: e2.Text }), o5 = e2.Record({ error: e2.Opt(e2.Text), timestamp_seconds: e2.Nat64, neuron_id: e2.Opt(t3) }), a = e2.Record({ authenticated_principal_id: e2.Opt(e2.Principal), successfully_transferred_neurons: e2.Vec(o5), is_whitelisted_for_forwarding: e2.Bool, has_donated: e2.Bool, failed_transferred_neurons: e2.Vec(o5), neuron_ids: e2.Vec(t3), has_claimed: e2.Bool, has_forwarded: e2.Bool, icpts: e2.Nat32 }), i2 = e2.Variant({ Ok: a, Err: e2.Text });
  return e2.Service({ balance: e2.Func([e2.Text], [e2.Nat32], ["query"]), claim_neurons: e2.Func([e2.Text], [r], []), donate_account: e2.Func([e2.Text], [n2], []), forward_whitelisted_unclaimed_accounts: e2.Func([e2.Null], [n2], []), get_account: e2.Func([e2.Text], [i2], ["query"]), get_build_metadata: e2.Func([], [e2.Text], ["query"]), len: e2.Func([], [e2.Nat16], ["query"]), total: e2.Func([], [e2.Nat32], ["query"]) });
};
var c2 = class {
  constructor(t3) {
    __publicField(this, "claimNeurons", async ({ hexPubKey: t3 }) => {
      let r = await this.service.claim_neurons(t3);
      if ("Ok" in r)
        return r.Ok.map((n2) => n2.id);
      throw new Error(r.Err);
    });
    this.service = t3;
  }
  static create(t3 = {}) {
    let { service: r } = X({ options: { ...t3, canisterId: t3.canisterId ?? t }, idlFactory: d2, certifiedIdlFactory: u });
    return new c2(r);
  }
};

// node_modules/@dfinity/nns/dist/esm/chunk-FCMD5MHU.js
var p2 = () => import("./esm-WXA56CJ3.js");
var l = async ({ agent: o5, canisterId: e2, methodName: r, arg: s2 }) => {
  let t3 = await o5.call(e2, { methodName: r, arg: s2, effectiveCanisterId: e2 });
  if (!t3.response.ok)
    throw new Error(["Call failed:", `  Method: ${r}`, `  Canister ID: ${e2}`, `  Request ID: ${t3.requestId}`, `  HTTP status code: ${t3.response.status}`, `  HTTP status text: ${t3.response.statusText}`].join(`
`));
  let a = await polling_exports.pollForResponse(o5, e2, t3.requestId, polling_exports.defaultStrategy());
  return new Uint8Array(a);
};
var u2 = async ({ agent: o5, canisterId: e2, methodName: r, arg: s2 }) => {
  let t3 = await o5.query(e2, { methodName: r, arg: s2 });
  if (t3.status == "rejected")
    throw new Error(["Call failed:", `  Method: ${r}`, `  Canister ID: ${e2}`, `  HTTP status code: ${t3.reject_code}`, `  HTTP status text: ${t3.reject_message}`].join(`
`));
  return new Uint8Array(t3.reply.arg);
};

// node_modules/@dfinity/nns/dist/esm/chunk-Q3ETFEQV.js
var g = Object.create;
var e = Object.defineProperty;
var h2 = Object.getOwnPropertyDescriptor;
var i = Object.getOwnPropertyNames;
var j = Object.getPrototypeOf;
var k2 = Object.prototype.hasOwnProperty;
var l2 = (b3, a, c3) => a in b3 ? e(b3, a, { enumerable: true, configurable: true, writable: true, value: c3 }) : b3[a] = c3;
var n = (b3, a) => () => (a || b3((a = { exports: {} }).exports, a), a.exports);
var m2 = (b3, a, c3, f2) => {
  if (a && typeof a == "object" || typeof a == "function")
    for (let d4 of i(a))
      !k2.call(b3, d4) && d4 !== c3 && e(b3, d4, { get: () => a[d4], enumerable: !(f2 = h2(a, d4)) || f2.enumerable });
  return b3;
};
var o2 = (b3, a, c3) => (c3 = b3 != null ? g(j(b3)) : {}, m2(a || !b3 || !b3.__esModule ? e(c3, "default", { value: b3, enumerable: true }) : c3, b3));
var p3 = (b3, a, c3) => (l2(b3, typeof a != "symbol" ? a + "" : a, c3), c3);

// node_modules/@dfinity/nns/dist/esm/chunk-4SFQPNVV.js
function T2(e2, ...t3) {
  if (!(e2 instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  if (t3.length > 0 && !t3.includes(e2.length))
    throw new Error(`Expected Uint8Array of length ${t3}, not of length=${e2.length}`);
}
function B(e2, t3 = true) {
  if (e2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t3 && e2.finished)
    throw new Error("Hash#digest() has already been called");
}
function N2(e2, t3) {
  T2(e2);
  let r = t3.outputLen;
  if (e2.length < r)
    throw new Error(`digestInto() expects output buffer of length at least ${r}`);
}
var P2 = (e2) => e2 instanceof Uint8Array;
var m3 = (e2) => new DataView(e2.buffer, e2.byteOffset, e2.byteLength);
var h3 = (e2, t3) => e2 << 32 - t3 | e2 >>> t3;
var V = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!V)
  throw new Error("Non little-endian hardware is not supported");
function j2(e2) {
  if (typeof e2 != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e2}`);
  return new Uint8Array(new TextEncoder().encode(e2));
}
function I(e2) {
  if (typeof e2 == "string" && (e2 = j2(e2)), !P2(e2))
    throw new Error(`expected Uint8Array, got ${typeof e2}`);
  return e2;
}
var g2 = class {
  clone() {
    return this._cloneInto();
  }
};
var q = {}.toString;
function C(e2) {
  let t3 = (n2) => e2().update(I(n2)).digest(), r = e2();
  return t3.outputLen = r.outputLen, t3.blockLen = r.blockLen, t3.create = () => e2(), t3;
}
function F(e2, t3, r, n2) {
  if (typeof e2.setBigUint64 == "function")
    return e2.setBigUint64(t3, r, n2);
  let o5 = BigInt(32), c3 = BigInt(4294967295), i2 = Number(r >> o5 & c3), s2 = Number(r & c3), a = n2 ? 4 : 0, u3 = n2 ? 0 : 4;
  e2.setUint32(t3 + a, i2, n2), e2.setUint32(t3 + u3, s2, n2);
}
var A2 = class extends g2 {
  constructor(t3, r, n2, o5) {
    super(), this.blockLen = t3, this.outputLen = r, this.padOffset = n2, this.isLE = o5, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t3), this.view = m3(this.buffer);
  }
  update(t3) {
    B(this);
    let { view: r, buffer: n2, blockLen: o5 } = this;
    t3 = I(t3);
    let c3 = t3.length;
    for (let i2 = 0; i2 < c3; ) {
      let s2 = Math.min(o5 - this.pos, c3 - i2);
      if (s2 === o5) {
        let a = m3(t3);
        for (; o5 <= c3 - i2; i2 += o5)
          this.process(a, i2);
        continue;
      }
      n2.set(t3.subarray(i2, i2 + s2), this.pos), this.pos += s2, i2 += s2, this.pos === o5 && (this.process(r, 0), this.pos = 0);
    }
    return this.length += t3.length, this.roundClean(), this;
  }
  digestInto(t3) {
    B(this), N2(t3, this), this.finished = true;
    let { buffer: r, view: n2, blockLen: o5, isLE: c3 } = this, { pos: i2 } = this;
    r[i2++] = 128, this.buffer.subarray(i2).fill(0), this.padOffset > o5 - i2 && (this.process(n2, 0), i2 = 0);
    for (let f2 = i2; f2 < o5; f2++)
      r[f2] = 0;
    F(n2, o5 - 8, BigInt(this.length * 8), c3), this.process(n2, 0);
    let s2 = m3(t3), a = this.outputLen;
    if (a % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    let u3 = a / 4, p5 = this.get();
    if (u3 > p5.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let f2 = 0; f2 < u3; f2++)
      s2.setUint32(4 * f2, p5[f2], c3);
  }
  digest() {
    let { buffer: t3, outputLen: r } = this;
    this.digestInto(t3);
    let n2 = t3.slice(0, r);
    return this.destroy(), n2;
  }
  _cloneInto(t3) {
    t3 || (t3 = new this.constructor()), t3.set(...this.get());
    let { blockLen: r, buffer: n2, length: o5, finished: c3, destroyed: i2, pos: s2 } = this;
    return t3.length = o5, t3.pos = s2, t3.finished = c3, t3.destroyed = i2, o5 % r && t3.buffer.set(n2), t3;
  }
};
var $2 = (e2, t3, r) => e2 & t3 ^ ~e2 & r;
var v = (e2, t3, r) => e2 & t3 ^ e2 & r ^ t3 & r;
var G = new Uint32Array([1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298]);
var x = new Uint32Array([1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225]);
var b2 = new Uint32Array(64);
var U = class extends A2 {
  constructor() {
    super(64, 32, 8, false), this.A = x[0] | 0, this.B = x[1] | 0, this.C = x[2] | 0, this.D = x[3] | 0, this.E = x[4] | 0, this.F = x[5] | 0, this.G = x[6] | 0, this.H = x[7] | 0;
  }
  get() {
    let { A: t3, B: r, C: n2, D: o5, E: c3, F: i2, G: s2, H: a } = this;
    return [t3, r, n2, o5, c3, i2, s2, a];
  }
  set(t3, r, n2, o5, c3, i2, s2, a) {
    this.A = t3 | 0, this.B = r | 0, this.C = n2 | 0, this.D = o5 | 0, this.E = c3 | 0, this.F = i2 | 0, this.G = s2 | 0, this.H = a | 0;
  }
  process(t3, r) {
    for (let f2 = 0; f2 < 16; f2++, r += 4)
      b2[f2] = t3.getUint32(r, false);
    for (let f2 = 16; f2 < 64; f2++) {
      let y = b2[f2 - 15], l3 = b2[f2 - 2], k4 = h3(y, 7) ^ h3(y, 18) ^ y >>> 3, L2 = h3(l3, 17) ^ h3(l3, 19) ^ l3 >>> 10;
      b2[f2] = L2 + b2[f2 - 7] + k4 + b2[f2 - 16] | 0;
    }
    let { A: n2, B: o5, C: c3, D: i2, E: s2, F: a, G: u3, H: p5 } = this;
    for (let f2 = 0; f2 < 64; f2++) {
      let y = h3(s2, 6) ^ h3(s2, 11) ^ h3(s2, 25), l3 = p5 + y + $2(s2, a, u3) + G[f2] + b2[f2] | 0, L2 = (h3(n2, 2) ^ h3(n2, 13) ^ h3(n2, 22)) + v(n2, o5, c3) | 0;
      p5 = u3, u3 = a, a = s2, s2 = i2 + l3 | 0, i2 = c3, c3 = o5, o5 = n2, n2 = l3 + L2 | 0;
    }
    n2 = n2 + this.A | 0, o5 = o5 + this.B | 0, c3 = c3 + this.C | 0, i2 = i2 + this.D | 0, s2 = s2 + this.E | 0, a = a + this.F | 0, u3 = u3 + this.G | 0, p5 = p5 + this.H | 0, this.set(n2, o5, c3, i2, s2, a, u3, p5);
  }
  roundClean() {
    b2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var H = class extends U {
  constructor() {
    super(), this.A = -1056596264, this.B = 914150663, this.C = 812702999, this.D = -150054599, this.E = -4191439, this.F = 1750603025, this.G = 1694076839, this.H = -1090891868, this.outputLen = 28;
  }
};
var tt = C(() => new U());
var S = C(() => new H());
var w = class {
  constructor(t3) {
    this.bytes = t3;
  }
  static fromHex(t3) {
    return new w(Uint8Array.from(Buffer.from(t3, "hex")));
  }
  static fromPrincipal({ principal: t3, subAccount: r = E2.ZERO }) {
    let n2 = se(`
account-id`), o5 = S.create();
    o5.update(xe([...n2, ...t3.toUint8Array(), ...r.toUint8Array()]));
    let c3 = o5.digest(), i2 = ye(c3), s2 = new Uint8Array([...i2, ...c3]);
    return new w(s2);
  }
  async toProto() {
    let { AccountIdentifier: t3 } = await p2(), r = new t3();
    return r.setHash(this.bytes), r;
  }
  toHex() {
    return fe(this.bytes);
  }
  toUint8Array() {
    return this.bytes;
  }
  toNumbers() {
    return Array.from(this.bytes);
  }
  toAccountIdentifierHash() {
    return { hash: this.toUint8Array() };
  }
};
var d3 = class {
  constructor(t3) {
    this.bytes = t3;
  }
  static fromBytes(t3) {
    return t3.length != 32 ? Error("Subaccount length must be 32-bytes") : new d3(t3);
  }
  static fromPrincipal(t3) {
    let r = new Uint8Array(32).fill(0), n2 = t3.toUint8Array();
    r[0] = n2.length;
    for (let o5 = 0; o5 < n2.length; o5++)
      r[1 + o5] = n2[o5];
    return new d3(r);
  }
  static fromID(t3) {
    if (t3 < 0 || t3 > 255)
      throw "Subaccount ID must be >= 0 and <= 255";
    let r = new Uint8Array(32).fill(0);
    return r[31] = t3, new d3(r);
  }
  toUint8Array() {
    return this.bytes;
  }
};
var E2 = d3;
p3(E2, "ZERO", d3.fromID(0));

// node_modules/@dfinity/nns/dist/esm/chunk-DGJWOAUC.js
var t2 = BigInt(1095062083);
var E3 = BigInt(1347768404);
var _2 = BigInt(1e4);
var o3 = BigInt(1e8);

// node_modules/@dfinity/nns/dist/esm/chunk-V7YCXQVA.js
var Fn = n((Ce) => {
  "use strict";
  Ce.byteLength = ar;
  Ce.toByteArray = sr;
  Ce.fromByteArray = dr;
  var A4 = [], T3 = [], rr = typeof Uint8Array < "u" ? Uint8Array : Array, rn = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (L2 = 0, Vn = rn.length; L2 < Vn; ++L2)
    A4[L2] = rn[L2], T3[rn.charCodeAt(L2)] = L2;
  var L2, Vn;
  T3["-".charCodeAt(0)] = 62;
  T3["_".charCodeAt(0)] = 63;
  function En(e2) {
    var t3 = e2.length;
    if (t3 % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var n2 = e2.indexOf("=");
    n2 === -1 && (n2 = t3);
    var o5 = n2 === t3 ? 0 : 4 - n2 % 4;
    return [n2, o5];
  }
  function ar(e2) {
    var t3 = En(e2), n2 = t3[0], o5 = t3[1];
    return (n2 + o5) * 3 / 4 - o5;
  }
  function ir(e2, t3, n2) {
    return (t3 + n2) * 3 / 4 - n2;
  }
  function sr(e2) {
    var t3, n2 = En(e2), o5 = n2[0], r = n2[1], a = new rr(ir(e2, o5, r)), i2 = 0, c3 = r > 0 ? o5 - 4 : o5, d4;
    for (d4 = 0; d4 < c3; d4 += 4)
      t3 = T3[e2.charCodeAt(d4)] << 18 | T3[e2.charCodeAt(d4 + 1)] << 12 | T3[e2.charCodeAt(d4 + 2)] << 6 | T3[e2.charCodeAt(d4 + 3)], a[i2++] = t3 >> 16 & 255, a[i2++] = t3 >> 8 & 255, a[i2++] = t3 & 255;
    return r === 2 && (t3 = T3[e2.charCodeAt(d4)] << 2 | T3[e2.charCodeAt(d4 + 1)] >> 4, a[i2++] = t3 & 255), r === 1 && (t3 = T3[e2.charCodeAt(d4)] << 10 | T3[e2.charCodeAt(d4 + 1)] << 4 | T3[e2.charCodeAt(d4 + 2)] >> 2, a[i2++] = t3 >> 8 & 255, a[i2++] = t3 & 255), a;
  }
  function cr(e2) {
    return A4[e2 >> 18 & 63] + A4[e2 >> 12 & 63] + A4[e2 >> 6 & 63] + A4[e2 & 63];
  }
  function ur(e2, t3, n2) {
    for (var o5, r = [], a = t3; a < n2; a += 3)
      o5 = (e2[a] << 16 & 16711680) + (e2[a + 1] << 8 & 65280) + (e2[a + 2] & 255), r.push(cr(o5));
    return r.join("");
  }
  function dr(e2) {
    for (var t3, n2 = e2.length, o5 = n2 % 3, r = [], a = 16383, i2 = 0, c3 = n2 - o5; i2 < c3; i2 += a)
      r.push(ur(e2, i2, i2 + a > c3 ? c3 : i2 + a));
    return o5 === 1 ? (t3 = e2[n2 - 1], r.push(A4[t3 >> 2] + A4[t3 << 4 & 63] + "==")) : o5 === 2 && (t3 = (e2[n2 - 2] << 8) + e2[n2 - 1], r.push(A4[t3 >> 10] + A4[t3 >> 4 & 63] + A4[t3 << 2 & 63] + "=")), r.join("");
  }
});
var Bn = n((an) => {
  an.read = function(e2, t3, n2, o5, r) {
    var a, i2, c3 = r * 8 - o5 - 1, d4 = (1 << c3) - 1, m4 = d4 >> 1, f2 = -7, _4 = n2 ? r - 1 : 0, y = n2 ? -1 : 1, g3 = e2[t3 + _4];
    for (_4 += y, a = g3 & (1 << -f2) - 1, g3 >>= -f2, f2 += c3; f2 > 0; a = a * 256 + e2[t3 + _4], _4 += y, f2 -= 8)
      ;
    for (i2 = a & (1 << -f2) - 1, a >>= -f2, f2 += o5; f2 > 0; i2 = i2 * 256 + e2[t3 + _4], _4 += y, f2 -= 8)
      ;
    if (a === 0)
      a = 1 - m4;
    else {
      if (a === d4)
        return i2 ? NaN : (g3 ? -1 : 1) * (1 / 0);
      i2 = i2 + Math.pow(2, o5), a = a - m4;
    }
    return (g3 ? -1 : 1) * i2 * Math.pow(2, a - o5);
  };
  an.write = function(e2, t3, n2, o5, r, a) {
    var i2, c3, d4, m4 = a * 8 - r - 1, f2 = (1 << m4) - 1, _4 = f2 >> 1, y = r === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, g3 = o5 ? 0 : a - 1, k4 = o5 ? 1 : -1, l3 = t3 < 0 || t3 === 0 && 1 / t3 < 0 ? 1 : 0;
    for (t3 = Math.abs(t3), isNaN(t3) || t3 === 1 / 0 ? (c3 = isNaN(t3) ? 1 : 0, i2 = f2) : (i2 = Math.floor(Math.log(t3) / Math.LN2), t3 * (d4 = Math.pow(2, -i2)) < 1 && (i2--, d4 *= 2), i2 + _4 >= 1 ? t3 += y / d4 : t3 += y * Math.pow(2, 1 - _4), t3 * d4 >= 2 && (i2++, d4 /= 2), i2 + _4 >= f2 ? (c3 = 0, i2 = f2) : i2 + _4 >= 1 ? (c3 = (t3 * d4 - 1) * Math.pow(2, r), i2 = i2 + _4) : (c3 = t3 * Math.pow(2, _4 - 1) * Math.pow(2, r), i2 = 0)); r >= 8; e2[n2 + g3] = c3 & 255, g3 += k4, c3 /= 256, r -= 8)
      ;
    for (i2 = i2 << r | c3, m4 += r; m4 > 0; e2[n2 + g3] = i2 & 255, g3 += k4, i2 /= 256, m4 -= 8)
      ;
    e2[n2 + g3 - k4] |= l3 * 128;
  };
});
var mn = n((oe2) => {
  "use strict";
  var sn = Fn(), ne3 = Bn(), qn = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  oe2.Buffer = s2;
  oe2.SlowBuffer = wr;
  oe2.INSPECT_MAX_BYTES = 50;
  var Pe = 2147483647;
  oe2.kMaxLength = Pe;
  s2.TYPED_ARRAY_SUPPORT = pr();
  !s2.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function pr() {
    try {
      var e2 = new Uint8Array(1), t3 = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(t3, Uint8Array.prototype), Object.setPrototypeOf(e2, t3), e2.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(s2.prototype, "parent", { enumerable: true, get: function() {
    if (s2.isBuffer(this))
      return this.buffer;
  } });
  Object.defineProperty(s2.prototype, "offset", { enumerable: true, get: function() {
    if (s2.isBuffer(this))
      return this.byteOffset;
  } });
  function G2(e2) {
    if (e2 > Pe)
      throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
    var t3 = new Uint8Array(e2);
    return Object.setPrototypeOf(t3, s2.prototype), t3;
  }
  function s2(e2, t3, n2) {
    if (typeof e2 == "number") {
      if (typeof t3 == "string")
        throw new TypeError('The "string" argument must be of type string. Received type number');
      return pn(e2);
    }
    return Hn(e2, t3, n2);
  }
  s2.poolSize = 8192;
  function Hn(e2, t3, n2) {
    if (typeof e2 == "string")
      return _r(e2, t3);
    if (ArrayBuffer.isView(e2))
      return mr(e2);
    if (e2 == null)
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
    if (V3(e2, ArrayBuffer) || e2 && V3(e2.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (V3(e2, SharedArrayBuffer) || e2 && V3(e2.buffer, SharedArrayBuffer)))
      return un(e2, t3, n2);
    if (typeof e2 == "number")
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    var o5 = e2.valueOf && e2.valueOf();
    if (o5 != null && o5 !== e2)
      return s2.from(o5, t3, n2);
    var r = fr(e2);
    if (r)
      return r;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof e2[Symbol.toPrimitive] == "function")
      return s2.from(e2[Symbol.toPrimitive]("string"), t3, n2);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e2);
  }
  s2.from = function(e2, t3, n2) {
    return Hn(e2, t3, n2);
  };
  Object.setPrototypeOf(s2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(s2, Uint8Array);
  function Wn(e2) {
    if (typeof e2 != "number")
      throw new TypeError('"size" argument must be of type number');
    if (e2 < 0)
      throw new RangeError('The value "' + e2 + '" is invalid for option "size"');
  }
  function lr(e2, t3, n2) {
    return Wn(e2), e2 <= 0 ? G2(e2) : t3 !== void 0 ? typeof n2 == "string" ? G2(e2).fill(t3, n2) : G2(e2).fill(t3) : G2(e2);
  }
  s2.alloc = function(e2, t3, n2) {
    return lr(e2, t3, n2);
  };
  function pn(e2) {
    return Wn(e2), G2(e2 < 0 ? 0 : ln(e2) | 0);
  }
  s2.allocUnsafe = function(e2) {
    return pn(e2);
  };
  s2.allocUnsafeSlow = function(e2) {
    return pn(e2);
  };
  function _r(e2, t3) {
    if ((typeof t3 != "string" || t3 === "") && (t3 = "utf8"), !s2.isEncoding(t3))
      throw new TypeError("Unknown encoding: " + t3);
    var n2 = Gn(e2, t3) | 0, o5 = G2(n2), r = o5.write(e2, t3);
    return r !== n2 && (o5 = o5.slice(0, r)), o5;
  }
  function cn(e2) {
    for (var t3 = e2.length < 0 ? 0 : ln(e2.length) | 0, n2 = G2(t3), o5 = 0; o5 < t3; o5 += 1)
      n2[o5] = e2[o5] & 255;
    return n2;
  }
  function mr(e2) {
    if (V3(e2, Uint8Array)) {
      var t3 = new Uint8Array(e2);
      return un(t3.buffer, t3.byteOffset, t3.byteLength);
    }
    return cn(e2);
  }
  function un(e2, t3, n2) {
    if (t3 < 0 || e2.byteLength < t3)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (e2.byteLength < t3 + (n2 || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var o5;
    return t3 === void 0 && n2 === void 0 ? o5 = new Uint8Array(e2) : n2 === void 0 ? o5 = new Uint8Array(e2, t3) : o5 = new Uint8Array(e2, t3, n2), Object.setPrototypeOf(o5, s2.prototype), o5;
  }
  function fr(e2) {
    if (s2.isBuffer(e2)) {
      var t3 = ln(e2.length) | 0, n2 = G2(t3);
      return n2.length === 0 || e2.copy(n2, 0, 0, t3), n2;
    }
    if (e2.length !== void 0)
      return typeof e2.length != "number" || _n(e2.length) ? G2(0) : cn(e2);
    if (e2.type === "Buffer" && Array.isArray(e2.data))
      return cn(e2.data);
  }
  function ln(e2) {
    if (e2 >= Pe)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + Pe.toString(16) + " bytes");
    return e2 | 0;
  }
  function wr(e2) {
    return +e2 != e2 && (e2 = 0), s2.alloc(+e2);
  }
  s2.isBuffer = function(t3) {
    return t3 != null && t3._isBuffer === true && t3 !== s2.prototype;
  };
  s2.compare = function(t3, n2) {
    if (V3(t3, Uint8Array) && (t3 = s2.from(t3, t3.offset, t3.byteLength)), V3(n2, Uint8Array) && (n2 = s2.from(n2, n2.offset, n2.byteLength)), !s2.isBuffer(t3) || !s2.isBuffer(n2))
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    if (t3 === n2)
      return 0;
    for (var o5 = t3.length, r = n2.length, a = 0, i2 = Math.min(o5, r); a < i2; ++a)
      if (t3[a] !== n2[a]) {
        o5 = t3[a], r = n2[a];
        break;
      }
    return o5 < r ? -1 : r < o5 ? 1 : 0;
  };
  s2.isEncoding = function(t3) {
    switch (String(t3).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  s2.concat = function(t3, n2) {
    if (!Array.isArray(t3))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (t3.length === 0)
      return s2.alloc(0);
    var o5;
    if (n2 === void 0)
      for (n2 = 0, o5 = 0; o5 < t3.length; ++o5)
        n2 += t3[o5].length;
    var r = s2.allocUnsafe(n2), a = 0;
    for (o5 = 0; o5 < t3.length; ++o5) {
      var i2 = t3[o5];
      if (V3(i2, Uint8Array))
        a + i2.length > r.length ? s2.from(i2).copy(r, a) : Uint8Array.prototype.set.call(r, i2, a);
      else if (s2.isBuffer(i2))
        i2.copy(r, a);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      a += i2.length;
    }
    return r;
  };
  function Gn(e2, t3) {
    if (s2.isBuffer(e2))
      return e2.length;
    if (ArrayBuffer.isView(e2) || V3(e2, ArrayBuffer))
      return e2.byteLength;
    if (typeof e2 != "string")
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof e2);
    var n2 = e2.length, o5 = arguments.length > 2 && arguments[2] === true;
    if (!o5 && n2 === 0)
      return 0;
    for (var r = false; ; )
      switch (t3) {
        case "ascii":
        case "latin1":
        case "binary":
          return n2;
        case "utf8":
        case "utf-8":
          return dn(e2).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return n2 * 2;
        case "hex":
          return n2 >>> 1;
        case "base64":
          return Yn(e2).length;
        default:
          if (r)
            return o5 ? -1 : dn(e2).length;
          t3 = ("" + t3).toLowerCase(), r = true;
      }
  }
  s2.byteLength = Gn;
  function Nr(e2, t3, n2) {
    var o5 = false;
    if ((t3 === void 0 || t3 < 0) && (t3 = 0), t3 > this.length || ((n2 === void 0 || n2 > this.length) && (n2 = this.length), n2 <= 0) || (n2 >>>= 0, t3 >>>= 0, n2 <= t3))
      return "";
    for (e2 || (e2 = "utf8"); ; )
      switch (e2) {
        case "hex":
          return kr(this, t3, n2);
        case "utf8":
        case "utf-8":
          return zn(this, t3, n2);
        case "ascii":
          return br(this, t3, n2);
        case "latin1":
        case "binary":
          return xr(this, t3, n2);
        case "base64":
          return Or(this, t3, n2);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Tr(this, t3, n2);
        default:
          if (o5)
            throw new TypeError("Unknown encoding: " + e2);
          e2 = (e2 + "").toLowerCase(), o5 = true;
      }
  }
  s2.prototype._isBuffer = true;
  function ee3(e2, t3, n2) {
    var o5 = e2[t3];
    e2[t3] = e2[n2], e2[n2] = o5;
  }
  s2.prototype.swap16 = function() {
    var t3 = this.length;
    if (t3 % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var n2 = 0; n2 < t3; n2 += 2)
      ee3(this, n2, n2 + 1);
    return this;
  };
  s2.prototype.swap32 = function() {
    var t3 = this.length;
    if (t3 % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var n2 = 0; n2 < t3; n2 += 4)
      ee3(this, n2, n2 + 3), ee3(this, n2 + 1, n2 + 2);
    return this;
  };
  s2.prototype.swap64 = function() {
    var t3 = this.length;
    if (t3 % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var n2 = 0; n2 < t3; n2 += 8)
      ee3(this, n2, n2 + 7), ee3(this, n2 + 1, n2 + 6), ee3(this, n2 + 2, n2 + 5), ee3(this, n2 + 3, n2 + 4);
    return this;
  };
  s2.prototype.toString = function() {
    var t3 = this.length;
    return t3 === 0 ? "" : arguments.length === 0 ? zn(this, 0, t3) : Nr.apply(this, arguments);
  };
  s2.prototype.toLocaleString = s2.prototype.toString;
  s2.prototype.equals = function(t3) {
    if (!s2.isBuffer(t3))
      throw new TypeError("Argument must be a Buffer");
    return this === t3 ? true : s2.compare(this, t3) === 0;
  };
  s2.prototype.inspect = function() {
    var t3 = "", n2 = oe2.INSPECT_MAX_BYTES;
    return t3 = this.toString("hex", 0, n2).replace(/(.{2})/g, "$1 ").trim(), this.length > n2 && (t3 += " ... "), "<Buffer " + t3 + ">";
  };
  qn && (s2.prototype[qn] = s2.prototype.inspect);
  s2.prototype.compare = function(t3, n2, o5, r, a) {
    if (V3(t3, Uint8Array) && (t3 = s2.from(t3, t3.offset, t3.byteLength)), !s2.isBuffer(t3))
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof t3);
    if (n2 === void 0 && (n2 = 0), o5 === void 0 && (o5 = t3 ? t3.length : 0), r === void 0 && (r = 0), a === void 0 && (a = this.length), n2 < 0 || o5 > t3.length || r < 0 || a > this.length)
      throw new RangeError("out of range index");
    if (r >= a && n2 >= o5)
      return 0;
    if (r >= a)
      return -1;
    if (n2 >= o5)
      return 1;
    if (n2 >>>= 0, o5 >>>= 0, r >>>= 0, a >>>= 0, this === t3)
      return 0;
    for (var i2 = a - r, c3 = o5 - n2, d4 = Math.min(i2, c3), m4 = this.slice(r, a), f2 = t3.slice(n2, o5), _4 = 0; _4 < d4; ++_4)
      if (m4[_4] !== f2[_4]) {
        i2 = m4[_4], c3 = f2[_4];
        break;
      }
    return i2 < c3 ? -1 : c3 < i2 ? 1 : 0;
  };
  function jn(e2, t3, n2, o5, r) {
    if (e2.length === 0)
      return -1;
    if (typeof n2 == "string" ? (o5 = n2, n2 = 0) : n2 > 2147483647 ? n2 = 2147483647 : n2 < -2147483648 && (n2 = -2147483648), n2 = +n2, _n(n2) && (n2 = r ? 0 : e2.length - 1), n2 < 0 && (n2 = e2.length + n2), n2 >= e2.length) {
      if (r)
        return -1;
      n2 = e2.length - 1;
    } else if (n2 < 0)
      if (r)
        n2 = 0;
      else
        return -1;
    if (typeof t3 == "string" && (t3 = s2.from(t3, o5)), s2.isBuffer(t3))
      return t3.length === 0 ? -1 : Un(e2, t3, n2, o5, r);
    if (typeof t3 == "number")
      return t3 = t3 & 255, typeof Uint8Array.prototype.indexOf == "function" ? r ? Uint8Array.prototype.indexOf.call(e2, t3, n2) : Uint8Array.prototype.lastIndexOf.call(e2, t3, n2) : Un(e2, [t3], n2, o5, r);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Un(e2, t3, n2, o5, r) {
    var a = 1, i2 = e2.length, c3 = t3.length;
    if (o5 !== void 0 && (o5 = String(o5).toLowerCase(), o5 === "ucs2" || o5 === "ucs-2" || o5 === "utf16le" || o5 === "utf-16le")) {
      if (e2.length < 2 || t3.length < 2)
        return -1;
      a = 2, i2 /= 2, c3 /= 2, n2 /= 2;
    }
    function d4(g3, k4) {
      return a === 1 ? g3[k4] : g3.readUInt16BE(k4 * a);
    }
    var m4;
    if (r) {
      var f2 = -1;
      for (m4 = n2; m4 < i2; m4++)
        if (d4(e2, m4) === d4(t3, f2 === -1 ? 0 : m4 - f2)) {
          if (f2 === -1 && (f2 = m4), m4 - f2 + 1 === c3)
            return f2 * a;
        } else
          f2 !== -1 && (m4 -= m4 - f2), f2 = -1;
    } else
      for (n2 + c3 > i2 && (n2 = i2 - c3), m4 = n2; m4 >= 0; m4--) {
        for (var _4 = true, y = 0; y < c3; y++)
          if (d4(e2, m4 + y) !== d4(t3, y)) {
            _4 = false;
            break;
          }
        if (_4)
          return m4;
      }
    return -1;
  }
  s2.prototype.includes = function(t3, n2, o5) {
    return this.indexOf(t3, n2, o5) !== -1;
  };
  s2.prototype.indexOf = function(t3, n2, o5) {
    return jn(this, t3, n2, o5, true);
  };
  s2.prototype.lastIndexOf = function(t3, n2, o5) {
    return jn(this, t3, n2, o5, false);
  };
  function yr(e2, t3, n2, o5) {
    n2 = Number(n2) || 0;
    var r = e2.length - n2;
    o5 ? (o5 = Number(o5), o5 > r && (o5 = r)) : o5 = r;
    var a = t3.length;
    o5 > a / 2 && (o5 = a / 2);
    for (var i2 = 0; i2 < o5; ++i2) {
      var c3 = parseInt(t3.substr(i2 * 2, 2), 16);
      if (_n(c3))
        return i2;
      e2[n2 + i2] = c3;
    }
    return i2;
  }
  function gr(e2, t3, n2, o5) {
    return Me(dn(t3, e2.length - n2), e2, n2, o5);
  }
  function Rr(e2, t3, n2, o5) {
    return Me(Mr(t3), e2, n2, o5);
  }
  function vr(e2, t3, n2, o5) {
    return Me(Yn(t3), e2, n2, o5);
  }
  function hr(e2, t3, n2, o5) {
    return Me(Ar(t3, e2.length - n2), e2, n2, o5);
  }
  s2.prototype.write = function(t3, n2, o5, r) {
    if (n2 === void 0)
      r = "utf8", o5 = this.length, n2 = 0;
    else if (o5 === void 0 && typeof n2 == "string")
      r = n2, o5 = this.length, n2 = 0;
    else if (isFinite(n2))
      n2 = n2 >>> 0, isFinite(o5) ? (o5 = o5 >>> 0, r === void 0 && (r = "utf8")) : (r = o5, o5 = void 0);
    else
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    var a = this.length - n2;
    if ((o5 === void 0 || o5 > a) && (o5 = a), t3.length > 0 && (o5 < 0 || n2 < 0) || n2 > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    r || (r = "utf8");
    for (var i2 = false; ; )
      switch (r) {
        case "hex":
          return yr(this, t3, n2, o5);
        case "utf8":
        case "utf-8":
          return gr(this, t3, n2, o5);
        case "ascii":
        case "latin1":
        case "binary":
          return Rr(this, t3, n2, o5);
        case "base64":
          return vr(this, t3, n2, o5);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return hr(this, t3, n2, o5);
        default:
          if (i2)
            throw new TypeError("Unknown encoding: " + r);
          r = ("" + r).toLowerCase(), i2 = true;
      }
  };
  s2.prototype.toJSON = function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  };
  function Or(e2, t3, n2) {
    return t3 === 0 && n2 === e2.length ? sn.fromByteArray(e2) : sn.fromByteArray(e2.slice(t3, n2));
  }
  function zn(e2, t3, n2) {
    n2 = Math.min(e2.length, n2);
    for (var o5 = [], r = t3; r < n2; ) {
      var a = e2[r], i2 = null, c3 = a > 239 ? 4 : a > 223 ? 3 : a > 191 ? 2 : 1;
      if (r + c3 <= n2) {
        var d4, m4, f2, _4;
        switch (c3) {
          case 1:
            a < 128 && (i2 = a);
            break;
          case 2:
            d4 = e2[r + 1], (d4 & 192) === 128 && (_4 = (a & 31) << 6 | d4 & 63, _4 > 127 && (i2 = _4));
            break;
          case 3:
            d4 = e2[r + 1], m4 = e2[r + 2], (d4 & 192) === 128 && (m4 & 192) === 128 && (_4 = (a & 15) << 12 | (d4 & 63) << 6 | m4 & 63, _4 > 2047 && (_4 < 55296 || _4 > 57343) && (i2 = _4));
            break;
          case 4:
            d4 = e2[r + 1], m4 = e2[r + 2], f2 = e2[r + 3], (d4 & 192) === 128 && (m4 & 192) === 128 && (f2 & 192) === 128 && (_4 = (a & 15) << 18 | (d4 & 63) << 12 | (m4 & 63) << 6 | f2 & 63, _4 > 65535 && _4 < 1114112 && (i2 = _4));
        }
      }
      i2 === null ? (i2 = 65533, c3 = 1) : i2 > 65535 && (i2 -= 65536, o5.push(i2 >>> 10 & 1023 | 55296), i2 = 56320 | i2 & 1023), o5.push(i2), r += c3;
    }
    return Sr(o5);
  }
  var Kn = 4096;
  function Sr(e2) {
    var t3 = e2.length;
    if (t3 <= Kn)
      return String.fromCharCode.apply(String, e2);
    for (var n2 = "", o5 = 0; o5 < t3; )
      n2 += String.fromCharCode.apply(String, e2.slice(o5, o5 += Kn));
    return n2;
  }
  function br(e2, t3, n2) {
    var o5 = "";
    n2 = Math.min(e2.length, n2);
    for (var r = t3; r < n2; ++r)
      o5 += String.fromCharCode(e2[r] & 127);
    return o5;
  }
  function xr(e2, t3, n2) {
    var o5 = "";
    n2 = Math.min(e2.length, n2);
    for (var r = t3; r < n2; ++r)
      o5 += String.fromCharCode(e2[r]);
    return o5;
  }
  function kr(e2, t3, n2) {
    var o5 = e2.length;
    (!t3 || t3 < 0) && (t3 = 0), (!n2 || n2 < 0 || n2 > o5) && (n2 = o5);
    for (var r = "", a = t3; a < n2; ++a)
      r += Vr[e2[a]];
    return r;
  }
  function Tr(e2, t3, n2) {
    for (var o5 = e2.slice(t3, n2), r = "", a = 0; a < o5.length - 1; a += 2)
      r += String.fromCharCode(o5[a] + o5[a + 1] * 256);
    return r;
  }
  s2.prototype.slice = function(t3, n2) {
    var o5 = this.length;
    t3 = ~~t3, n2 = n2 === void 0 ? o5 : ~~n2, t3 < 0 ? (t3 += o5, t3 < 0 && (t3 = 0)) : t3 > o5 && (t3 = o5), n2 < 0 ? (n2 += o5, n2 < 0 && (n2 = 0)) : n2 > o5 && (n2 = o5), n2 < t3 && (n2 = t3);
    var r = this.subarray(t3, n2);
    return Object.setPrototypeOf(r, s2.prototype), r;
  };
  function R(e2, t3, n2) {
    if (e2 % 1 !== 0 || e2 < 0)
      throw new RangeError("offset is not uint");
    if (e2 + t3 > n2)
      throw new RangeError("Trying to access beyond buffer length");
  }
  s2.prototype.readUintLE = s2.prototype.readUIntLE = function(t3, n2, o5) {
    t3 = t3 >>> 0, n2 = n2 >>> 0, o5 || R(t3, n2, this.length);
    for (var r = this[t3], a = 1, i2 = 0; ++i2 < n2 && (a *= 256); )
      r += this[t3 + i2] * a;
    return r;
  };
  s2.prototype.readUintBE = s2.prototype.readUIntBE = function(t3, n2, o5) {
    t3 = t3 >>> 0, n2 = n2 >>> 0, o5 || R(t3, n2, this.length);
    for (var r = this[t3 + --n2], a = 1; n2 > 0 && (a *= 256); )
      r += this[t3 + --n2] * a;
    return r;
  };
  s2.prototype.readUint8 = s2.prototype.readUInt8 = function(t3, n2) {
    return t3 = t3 >>> 0, n2 || R(t3, 1, this.length), this[t3];
  };
  s2.prototype.readUint16LE = s2.prototype.readUInt16LE = function(t3, n2) {
    return t3 = t3 >>> 0, n2 || R(t3, 2, this.length), this[t3] | this[t3 + 1] << 8;
  };
  s2.prototype.readUint16BE = s2.prototype.readUInt16BE = function(t3, n2) {
    return t3 = t3 >>> 0, n2 || R(t3, 2, this.length), this[t3] << 8 | this[t3 + 1];
  };
  s2.prototype.readUint32LE = s2.prototype.readUInt32LE = function(t3, n2) {
    return t3 = t3 >>> 0, n2 || R(t3, 4, this.length), (this[t3] | this[t3 + 1] << 8 | this[t3 + 2] << 16) + this[t3 + 3] * 16777216;
  };
  s2.prototype.readUint32BE = s2.prototype.readUInt32BE = function(t3, n2) {
    return t3 = t3 >>> 0, n2 || R(t3, 4, this.length), this[t3] * 16777216 + (this[t3 + 1] << 16 | this[t3 + 2] << 8 | this[t3 + 3]);
  };
  s2.prototype.readIntLE = function(t3, n2, o5) {
    t3 = t3 >>> 0, n2 = n2 >>> 0, o5 || R(t3, n2, this.length);
    for (var r = this[t3], a = 1, i2 = 0; ++i2 < n2 && (a *= 256); )
      r += this[t3 + i2] * a;
    return a *= 128, r >= a && (r -= Math.pow(2, 8 * n2)), r;
  };
  s2.prototype.readIntBE = function(t3, n2, o5) {
    t3 = t3 >>> 0, n2 = n2 >>> 0, o5 || R(t3, n2, this.length);
    for (var r = n2, a = 1, i2 = this[t3 + --r]; r > 0 && (a *= 256); )
      i2 += this[t3 + --r] * a;
    return a *= 128, i2 >= a && (i2 -= Math.pow(2, 8 * n2)), i2;
  };
  s2.prototype.readInt8 = function(t3, n2) {
    return t3 = t3 >>> 0, n2 || R(t3, 1, this.length), this[t3] & 128 ? (255 - this[t3] + 1) * -1 : this[t3];
  };
  s2.prototype.readInt16LE = function(t3, n2) {
    t3 = t3 >>> 0, n2 || R(t3, 2, this.length);
    var o5 = this[t3] | this[t3 + 1] << 8;
    return o5 & 32768 ? o5 | 4294901760 : o5;
  };
  s2.prototype.readInt16BE = function(t3, n2) {
    t3 = t3 >>> 0, n2 || R(t3, 2, this.length);
    var o5 = this[t3 + 1] | this[t3] << 8;
    return o5 & 32768 ? o5 | 4294901760 : o5;
  };
  s2.prototype.readInt32LE = function(t3, n2) {
    return t3 = t3 >>> 0, n2 || R(t3, 4, this.length), this[t3] | this[t3 + 1] << 8 | this[t3 + 2] << 16 | this[t3 + 3] << 24;
  };
  s2.prototype.readInt32BE = function(t3, n2) {
    return t3 = t3 >>> 0, n2 || R(t3, 4, this.length), this[t3] << 24 | this[t3 + 1] << 16 | this[t3 + 2] << 8 | this[t3 + 3];
  };
  s2.prototype.readFloatLE = function(t3, n2) {
    return t3 = t3 >>> 0, n2 || R(t3, 4, this.length), ne3.read(this, t3, true, 23, 4);
  };
  s2.prototype.readFloatBE = function(t3, n2) {
    return t3 = t3 >>> 0, n2 || R(t3, 4, this.length), ne3.read(this, t3, false, 23, 4);
  };
  s2.prototype.readDoubleLE = function(t3, n2) {
    return t3 = t3 >>> 0, n2 || R(t3, 8, this.length), ne3.read(this, t3, true, 52, 8);
  };
  s2.prototype.readDoubleBE = function(t3, n2) {
    return t3 = t3 >>> 0, n2 || R(t3, 8, this.length), ne3.read(this, t3, false, 52, 8);
  };
  function b3(e2, t3, n2, o5, r, a) {
    if (!s2.isBuffer(e2))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (t3 > r || t3 < a)
      throw new RangeError('"value" argument is out of bounds');
    if (n2 + o5 > e2.length)
      throw new RangeError("Index out of range");
  }
  s2.prototype.writeUintLE = s2.prototype.writeUIntLE = function(t3, n2, o5, r) {
    if (t3 = +t3, n2 = n2 >>> 0, o5 = o5 >>> 0, !r) {
      var a = Math.pow(2, 8 * o5) - 1;
      b3(this, t3, n2, o5, a, 0);
    }
    var i2 = 1, c3 = 0;
    for (this[n2] = t3 & 255; ++c3 < o5 && (i2 *= 256); )
      this[n2 + c3] = t3 / i2 & 255;
    return n2 + o5;
  };
  s2.prototype.writeUintBE = s2.prototype.writeUIntBE = function(t3, n2, o5, r) {
    if (t3 = +t3, n2 = n2 >>> 0, o5 = o5 >>> 0, !r) {
      var a = Math.pow(2, 8 * o5) - 1;
      b3(this, t3, n2, o5, a, 0);
    }
    var i2 = o5 - 1, c3 = 1;
    for (this[n2 + i2] = t3 & 255; --i2 >= 0 && (c3 *= 256); )
      this[n2 + i2] = t3 / c3 & 255;
    return n2 + o5;
  };
  s2.prototype.writeUint8 = s2.prototype.writeUInt8 = function(t3, n2, o5) {
    return t3 = +t3, n2 = n2 >>> 0, o5 || b3(this, t3, n2, 1, 255, 0), this[n2] = t3 & 255, n2 + 1;
  };
  s2.prototype.writeUint16LE = s2.prototype.writeUInt16LE = function(t3, n2, o5) {
    return t3 = +t3, n2 = n2 >>> 0, o5 || b3(this, t3, n2, 2, 65535, 0), this[n2] = t3 & 255, this[n2 + 1] = t3 >>> 8, n2 + 2;
  };
  s2.prototype.writeUint16BE = s2.prototype.writeUInt16BE = function(t3, n2, o5) {
    return t3 = +t3, n2 = n2 >>> 0, o5 || b3(this, t3, n2, 2, 65535, 0), this[n2] = t3 >>> 8, this[n2 + 1] = t3 & 255, n2 + 2;
  };
  s2.prototype.writeUint32LE = s2.prototype.writeUInt32LE = function(t3, n2, o5) {
    return t3 = +t3, n2 = n2 >>> 0, o5 || b3(this, t3, n2, 4, 4294967295, 0), this[n2 + 3] = t3 >>> 24, this[n2 + 2] = t3 >>> 16, this[n2 + 1] = t3 >>> 8, this[n2] = t3 & 255, n2 + 4;
  };
  s2.prototype.writeUint32BE = s2.prototype.writeUInt32BE = function(t3, n2, o5) {
    return t3 = +t3, n2 = n2 >>> 0, o5 || b3(this, t3, n2, 4, 4294967295, 0), this[n2] = t3 >>> 24, this[n2 + 1] = t3 >>> 16, this[n2 + 2] = t3 >>> 8, this[n2 + 3] = t3 & 255, n2 + 4;
  };
  s2.prototype.writeIntLE = function(t3, n2, o5, r) {
    if (t3 = +t3, n2 = n2 >>> 0, !r) {
      var a = Math.pow(2, 8 * o5 - 1);
      b3(this, t3, n2, o5, a - 1, -a);
    }
    var i2 = 0, c3 = 1, d4 = 0;
    for (this[n2] = t3 & 255; ++i2 < o5 && (c3 *= 256); )
      t3 < 0 && d4 === 0 && this[n2 + i2 - 1] !== 0 && (d4 = 1), this[n2 + i2] = (t3 / c3 >> 0) - d4 & 255;
    return n2 + o5;
  };
  s2.prototype.writeIntBE = function(t3, n2, o5, r) {
    if (t3 = +t3, n2 = n2 >>> 0, !r) {
      var a = Math.pow(2, 8 * o5 - 1);
      b3(this, t3, n2, o5, a - 1, -a);
    }
    var i2 = o5 - 1, c3 = 1, d4 = 0;
    for (this[n2 + i2] = t3 & 255; --i2 >= 0 && (c3 *= 256); )
      t3 < 0 && d4 === 0 && this[n2 + i2 + 1] !== 0 && (d4 = 1), this[n2 + i2] = (t3 / c3 >> 0) - d4 & 255;
    return n2 + o5;
  };
  s2.prototype.writeInt8 = function(t3, n2, o5) {
    return t3 = +t3, n2 = n2 >>> 0, o5 || b3(this, t3, n2, 1, 127, -128), t3 < 0 && (t3 = 255 + t3 + 1), this[n2] = t3 & 255, n2 + 1;
  };
  s2.prototype.writeInt16LE = function(t3, n2, o5) {
    return t3 = +t3, n2 = n2 >>> 0, o5 || b3(this, t3, n2, 2, 32767, -32768), this[n2] = t3 & 255, this[n2 + 1] = t3 >>> 8, n2 + 2;
  };
  s2.prototype.writeInt16BE = function(t3, n2, o5) {
    return t3 = +t3, n2 = n2 >>> 0, o5 || b3(this, t3, n2, 2, 32767, -32768), this[n2] = t3 >>> 8, this[n2 + 1] = t3 & 255, n2 + 2;
  };
  s2.prototype.writeInt32LE = function(t3, n2, o5) {
    return t3 = +t3, n2 = n2 >>> 0, o5 || b3(this, t3, n2, 4, 2147483647, -2147483648), this[n2] = t3 & 255, this[n2 + 1] = t3 >>> 8, this[n2 + 2] = t3 >>> 16, this[n2 + 3] = t3 >>> 24, n2 + 4;
  };
  s2.prototype.writeInt32BE = function(t3, n2, o5) {
    return t3 = +t3, n2 = n2 >>> 0, o5 || b3(this, t3, n2, 4, 2147483647, -2147483648), t3 < 0 && (t3 = 4294967295 + t3 + 1), this[n2] = t3 >>> 24, this[n2 + 1] = t3 >>> 16, this[n2 + 2] = t3 >>> 8, this[n2 + 3] = t3 & 255, n2 + 4;
  };
  function Jn(e2, t3, n2, o5, r, a) {
    if (n2 + o5 > e2.length)
      throw new RangeError("Index out of range");
    if (n2 < 0)
      throw new RangeError("Index out of range");
  }
  function $n(e2, t3, n2, o5, r) {
    return t3 = +t3, n2 = n2 >>> 0, r || Jn(e2, t3, n2, 4, 34028234663852886e22, -34028234663852886e22), ne3.write(e2, t3, n2, o5, 23, 4), n2 + 4;
  }
  s2.prototype.writeFloatLE = function(t3, n2, o5) {
    return $n(this, t3, n2, true, o5);
  };
  s2.prototype.writeFloatBE = function(t3, n2, o5) {
    return $n(this, t3, n2, false, o5);
  };
  function Xn(e2, t3, n2, o5, r) {
    return t3 = +t3, n2 = n2 >>> 0, r || Jn(e2, t3, n2, 8, 17976931348623157e292, -17976931348623157e292), ne3.write(e2, t3, n2, o5, 52, 8), n2 + 8;
  }
  s2.prototype.writeDoubleLE = function(t3, n2, o5) {
    return Xn(this, t3, n2, true, o5);
  };
  s2.prototype.writeDoubleBE = function(t3, n2, o5) {
    return Xn(this, t3, n2, false, o5);
  };
  s2.prototype.copy = function(t3, n2, o5, r) {
    if (!s2.isBuffer(t3))
      throw new TypeError("argument should be a Buffer");
    if (o5 || (o5 = 0), !r && r !== 0 && (r = this.length), n2 >= t3.length && (n2 = t3.length), n2 || (n2 = 0), r > 0 && r < o5 && (r = o5), r === o5 || t3.length === 0 || this.length === 0)
      return 0;
    if (n2 < 0)
      throw new RangeError("targetStart out of bounds");
    if (o5 < 0 || o5 >= this.length)
      throw new RangeError("Index out of range");
    if (r < 0)
      throw new RangeError("sourceEnd out of bounds");
    r > this.length && (r = this.length), t3.length - n2 < r - o5 && (r = t3.length - n2 + o5);
    var a = r - o5;
    return this === t3 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(n2, o5, r) : Uint8Array.prototype.set.call(t3, this.subarray(o5, r), n2), a;
  };
  s2.prototype.fill = function(t3, n2, o5, r) {
    if (typeof t3 == "string") {
      if (typeof n2 == "string" ? (r = n2, n2 = 0, o5 = this.length) : typeof o5 == "string" && (r = o5, o5 = this.length), r !== void 0 && typeof r != "string")
        throw new TypeError("encoding must be a string");
      if (typeof r == "string" && !s2.isEncoding(r))
        throw new TypeError("Unknown encoding: " + r);
      if (t3.length === 1) {
        var a = t3.charCodeAt(0);
        (r === "utf8" && a < 128 || r === "latin1") && (t3 = a);
      }
    } else
      typeof t3 == "number" ? t3 = t3 & 255 : typeof t3 == "boolean" && (t3 = Number(t3));
    if (n2 < 0 || this.length < n2 || this.length < o5)
      throw new RangeError("Out of range index");
    if (o5 <= n2)
      return this;
    n2 = n2 >>> 0, o5 = o5 === void 0 ? this.length : o5 >>> 0, t3 || (t3 = 0);
    var i2;
    if (typeof t3 == "number")
      for (i2 = n2; i2 < o5; ++i2)
        this[i2] = t3;
    else {
      var c3 = s2.isBuffer(t3) ? t3 : s2.from(t3, r), d4 = c3.length;
      if (d4 === 0)
        throw new TypeError('The value "' + t3 + '" is invalid for argument "value"');
      for (i2 = 0; i2 < o5 - n2; ++i2)
        this[i2 + n2] = c3[i2 % d4];
    }
    return this;
  };
  var Cr = /[^+/0-9A-Za-z-_]/g;
  function Pr(e2) {
    if (e2 = e2.split("=")[0], e2 = e2.trim().replace(Cr, ""), e2.length < 2)
      return "";
    for (; e2.length % 4 !== 0; )
      e2 = e2 + "=";
    return e2;
  }
  function dn(e2, t3) {
    t3 = t3 || 1 / 0;
    for (var n2, o5 = e2.length, r = null, a = [], i2 = 0; i2 < o5; ++i2) {
      if (n2 = e2.charCodeAt(i2), n2 > 55295 && n2 < 57344) {
        if (!r) {
          if (n2 > 56319) {
            (t3 -= 3) > -1 && a.push(239, 191, 189);
            continue;
          } else if (i2 + 1 === o5) {
            (t3 -= 3) > -1 && a.push(239, 191, 189);
            continue;
          }
          r = n2;
          continue;
        }
        if (n2 < 56320) {
          (t3 -= 3) > -1 && a.push(239, 191, 189), r = n2;
          continue;
        }
        n2 = (r - 55296 << 10 | n2 - 56320) + 65536;
      } else
        r && (t3 -= 3) > -1 && a.push(239, 191, 189);
      if (r = null, n2 < 128) {
        if ((t3 -= 1) < 0)
          break;
        a.push(n2);
      } else if (n2 < 2048) {
        if ((t3 -= 2) < 0)
          break;
        a.push(n2 >> 6 | 192, n2 & 63 | 128);
      } else if (n2 < 65536) {
        if ((t3 -= 3) < 0)
          break;
        a.push(n2 >> 12 | 224, n2 >> 6 & 63 | 128, n2 & 63 | 128);
      } else if (n2 < 1114112) {
        if ((t3 -= 4) < 0)
          break;
        a.push(n2 >> 18 | 240, n2 >> 12 & 63 | 128, n2 >> 6 & 63 | 128, n2 & 63 | 128);
      } else
        throw new Error("Invalid code point");
    }
    return a;
  }
  function Mr(e2) {
    for (var t3 = [], n2 = 0; n2 < e2.length; ++n2)
      t3.push(e2.charCodeAt(n2) & 255);
    return t3;
  }
  function Ar(e2, t3) {
    for (var n2, o5, r, a = [], i2 = 0; i2 < e2.length && !((t3 -= 2) < 0); ++i2)
      n2 = e2.charCodeAt(i2), o5 = n2 >> 8, r = n2 % 256, a.push(r), a.push(o5);
    return a;
  }
  function Yn(e2) {
    return sn.toByteArray(Pr(e2));
  }
  function Me(e2, t3, n2, o5) {
    for (var r = 0; r < o5 && !(r + n2 >= t3.length || r >= e2.length); ++r)
      t3[r + n2] = e2[r];
    return r;
  }
  function V3(e2, t3) {
    return e2 instanceof t3 || e2 != null && e2.constructor != null && e2.constructor.name != null && e2.constructor.name === t3.name;
  }
  function _n(e2) {
    return e2 !== e2;
  }
  var Vr = function() {
    for (var e2 = "0123456789abcdef", t3 = new Array(256), n2 = 0; n2 < 16; ++n2)
      for (var o5 = n2 * 16, r = 0; r < 16; ++r)
        t3[o5 + r] = e2[n2] + e2[r];
    return t3;
  }();
});
var In = n((fn, Zn) => {
  var Ae = mn(), j3 = Ae.Buffer;
  function Qn(e2, t3) {
    for (var n2 in e2)
      t3[n2] = e2[n2];
  }
  j3.from && j3.alloc && j3.allocUnsafe && j3.allocUnsafeSlow ? Zn.exports = Ae : (Qn(Ae, fn), fn.Buffer = re2);
  function re2(e2, t3, n2) {
    return j3(e2, t3, n2);
  }
  Qn(j3, re2);
  re2.from = function(e2, t3, n2) {
    if (typeof e2 == "number")
      throw new TypeError("Argument must not be a number");
    return j3(e2, t3, n2);
  };
  re2.alloc = function(e2, t3, n2) {
    if (typeof e2 != "number")
      throw new TypeError("Argument must be a number");
    var o5 = j3(e2);
    return t3 !== void 0 ? typeof n2 == "string" ? o5.fill(t3, n2) : o5.fill(t3) : o5.fill(0), o5;
  };
  re2.allocUnsafe = function(e2) {
    if (typeof e2 != "number")
      throw new TypeError("Argument must be a number");
    return j3(e2);
  };
  re2.allocUnsafeSlow = function(e2) {
    if (typeof e2 != "number")
      throw new TypeError("Argument must be a number");
    return Ae.SlowBuffer(e2);
  };
});
var Dn = n((Za, Nn) => {
  "use strict";
  var wn = 65536, Er = 4294967295;
  function Fr() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var Br = In().Buffer, Ve = window.crypto || window.msCrypto;
  Ve && Ve.getRandomValues ? Nn.exports = qr : Nn.exports = Fr;
  function qr(e2, t3) {
    if (e2 > Er)
      throw new RangeError("requested too many random bytes");
    var n2 = Br.allocUnsafe(e2);
    if (e2 > 0)
      if (e2 > wn)
        for (var o5 = 0; o5 < e2; o5 += wn)
          Ve.getRandomValues(n2.slice(o5, o5 + wn));
      else
        Ve.getRandomValues(n2);
    return typeof t3 == "function" ? process.nextTick(function() {
      t3(null, n2);
    }) : n2;
  }
});
var nr = o2(Dn());
var Ln = ({ IDL: e2 }) => {
  let t3 = e2.Rec(), n2 = e2.Record({ id: e2.Nat64 }), o5 = e2.Record({ followees: e2.Vec(n2) }), r = e2.Record({ hash: e2.Vec(e2.Nat8) }), a = e2.Record({ id: e2.Opt(e2.Principal), reward_account: e2.Opt(r) }), i2 = e2.Record({ dissolve_delay_seconds: e2.Nat64 }), c3 = e2.Record({ to_account: e2.Opt(r) }), d4 = e2.Variant({ RewardToNeuron: i2, RewardToAccount: c3 }), m4 = e2.Record({ node_provider: e2.Opt(a), reward_mode: e2.Opt(d4), amount_e8s: e2.Nat64 }), f2 = e2.Record({ timestamp: e2.Nat64, rewards: e2.Vec(m4) }), _4 = e2.Record({ not_dissolving_neurons_e8s_buckets: e2.Vec(e2.Tuple(e2.Nat64, e2.Float64)), garbage_collectable_neurons_count: e2.Nat64, neurons_with_invalid_stake_count: e2.Nat64, not_dissolving_neurons_count_buckets: e2.Vec(e2.Tuple(e2.Nat64, e2.Nat64)), total_supply_icp: e2.Nat64, neurons_with_less_than_6_months_dissolve_delay_count: e2.Nat64, dissolved_neurons_count: e2.Nat64, community_fund_total_maturity_e8s_equivalent: e2.Nat64, total_staked_e8s: e2.Nat64, not_dissolving_neurons_count: e2.Nat64, total_locked_e8s: e2.Nat64, dissolved_neurons_e8s: e2.Nat64, neurons_with_less_than_6_months_dissolve_delay_e8s: e2.Nat64, dissolving_neurons_count_buckets: e2.Vec(e2.Tuple(e2.Nat64, e2.Nat64)), dissolving_neurons_count: e2.Nat64, dissolving_neurons_e8s_buckets: e2.Vec(e2.Tuple(e2.Nat64, e2.Float64)), community_fund_total_staked_e8s: e2.Nat64, timestamp_seconds: e2.Nat64 }), y = e2.Record({ neuron_minimum_stake_e8s: e2.Nat64, max_proposals_to_keep_per_topic: e2.Nat32, neuron_management_fee_per_proposal_e8s: e2.Nat64, reject_cost_e8s: e2.Nat64, transaction_fee_e8s: e2.Nat64, neuron_spawn_dissolve_delay_seconds: e2.Nat64, minimum_icp_xdr_rate: e2.Nat64, maximum_node_provider_rewards_e8s: e2.Nat64 }), g3 = e2.Record({ rounds_since_last_distribution: e2.Opt(e2.Nat64), day_after_genesis: e2.Nat64, actual_timestamp_seconds: e2.Nat64, total_available_e8s_equivalent: e2.Nat64, latest_round_available_e8s_equivalent: e2.Opt(e2.Nat64), distributed_e8s_equivalent: e2.Nat64, settled_proposals: e2.Vec(n2) }), k4 = e2.Record({ to_subaccount: e2.Vec(e2.Nat8), neuron_stake_e8s: e2.Nat64, from: e2.Opt(e2.Principal), memo: e2.Nat64, from_subaccount: e2.Vec(e2.Nat8), transfer_timestamp: e2.Nat64, block_height: e2.Nat64 }), l3 = e2.Record({ error_message: e2.Text, error_type: e2.Int32 }), je = e2.Record({ nns_neuron_id: e2.Nat64, amount_icp_e8s: e2.Nat64 }), ze = e2.Record({ hotkey_principal: e2.Text, cf_neurons: e2.Vec(je) }), ie = e2.Record({ vote: e2.Int32, voting_power: e2.Nat64 }), Je = e2.Record({ status: e2.Opt(e2.Int32), freezing_threshold: e2.Opt(e2.Nat64), controllers: e2.Vec(e2.Principal), memory_size: e2.Opt(e2.Nat64), cycles: e2.Opt(e2.Nat64), idle_cycles_burned_per_day: e2.Opt(e2.Nat64), module_hash: e2.Vec(e2.Nat8) }), O = e2.Record({ status: e2.Opt(Je), canister_id: e2.Opt(e2.Principal) }), $e = e2.Record({ ledger_index_canister_summary: e2.Opt(O), fallback_controller_principal_ids: e2.Vec(e2.Principal), ledger_archive_canister_summaries: e2.Vec(O), ledger_canister_summary: e2.Opt(O), swap_canister_summary: e2.Opt(O), governance_canister_summary: e2.Opt(O), root_canister_summary: e2.Opt(O), dapp_canister_summaries: e2.Vec(O) }), se2 = e2.Record({ swap_background_information: e2.Opt($e) }), ce3 = e2.Record({ no: e2.Nat64, yes: e2.Nat64, total: e2.Nat64, timestamp_seconds: e2.Nat64 }), Y3 = e2.Record({ name: e2.Text, description: e2.Opt(e2.Text) }), ue = e2.Record({ id: e2.Opt(n2), known_neuron_data: e2.Opt(Y3) }), Xe = e2.Record({ percentage_to_spawn: e2.Opt(e2.Nat32), new_controller: e2.Opt(e2.Principal), nonce: e2.Opt(e2.Nat64) }), de = e2.Record({ amount_e8s: e2.Nat64 }), Ye = e2.Record({ topic: e2.Int32, followees: e2.Vec(n2) }), pe = e2.Record({ controller: e2.Opt(e2.Principal), memo: e2.Nat64 }), Qe = e2.Variant({ NeuronIdOrSubaccount: e2.Record({}), MemoAndController: pe, Memo: e2.Nat64 }), le = e2.Record({ by: e2.Opt(Qe) }), Ze = e2.Record({ hot_key_to_remove: e2.Opt(e2.Principal) }), Ie = e2.Record({ new_hot_key: e2.Opt(e2.Principal) }), De = e2.Record({ requested_setting_for_auto_stake_maturity: e2.Bool }), Le = e2.Record({ additional_dissolve_delay_seconds: e2.Nat32 }), et = e2.Record({ dissolve_timestamp_seconds: e2.Nat64 }), tt2 = e2.Variant({ RemoveHotKey: Ze, AddHotKey: Ie, ChangeAutoStakeMaturity: De, StopDissolving: e2.Record({}), StartDissolving: e2.Record({}), IncreaseDissolveDelay: Le, JoinCommunityFund: e2.Record({}), LeaveCommunityFund: e2.Record({}), SetDissolveTimestamp: et }), _e = e2.Record({ operation: e2.Opt(tt2) }), nt = e2.Record({ vote: e2.Int32, proposal: e2.Opt(n2) }), u3 = e2.Record({ source_neuron_id: e2.Opt(n2) }), me = e2.Record({ dissolve_delay_seconds: e2.Nat64, kyc_verified: e2.Bool, amount_e8s: e2.Nat64, new_controller: e2.Opt(e2.Principal), nonce: e2.Nat64 }), ot = e2.Record({ percentage_to_stake: e2.Opt(e2.Nat32) }), fe2 = e2.Record({ percentage_to_merge: e2.Nat32 }), rt = e2.Record({ e8s: e2.Nat64 }), we2 = e2.Record({ to_account: e2.Opt(r), amount: e2.Opt(rt) }), at = e2.Variant({ Spawn: Xe, Split: de, Follow: Ye, ClaimOrRefresh: le, Configure: _e, RegisterVote: nt, Merge: u3, DisburseToNeuron: me, MakeProposal: t3, StakeMaturity: ot, MergeMaturity: fe2, Disburse: we2 }), Q = e2.Variant({ Subaccount: e2.Vec(e2.Nat8), NeuronId: n2 }), Z3 = e2.Record({ id: e2.Opt(n2), command: e2.Opt(at), neuron_id_or_subaccount: e2.Opt(Q) }), K3 = e2.Record({ basis_points: e2.Opt(e2.Nat64) }), w2 = e2.Record({ seconds: e2.Opt(e2.Nat64) }), N4 = e2.Record({ e8s: e2.Opt(e2.Nat64) }), it = e2.Record({ reward_rate_transition_duration: e2.Opt(w2), initial_reward_rate: e2.Opt(K3), final_reward_rate: e2.Opt(K3) }), st = e2.Record({ neuron_maximum_dissolve_delay_bonus: e2.Opt(K3), neuron_maximum_age_for_age_bonus: e2.Opt(w2), neuron_maximum_dissolve_delay: e2.Opt(w2), neuron_minimum_dissolve_delay_to_vote: e2.Opt(w2), neuron_maximum_age_bonus: e2.Opt(K3), neuron_minimum_stake: e2.Opt(N4), proposal_wait_for_quiet_deadline_increase: e2.Opt(w2), proposal_initial_voting_period: e2.Opt(w2), proposal_rejection_fee: e2.Opt(N4), voting_reward_parameters: e2.Opt(it) }), Ne = e2.Record({ base64_encoding: e2.Opt(e2.Text) }), ct = e2.Record({ transaction_fee: e2.Opt(N4), token_symbol: e2.Opt(e2.Text), token_logo: e2.Opt(Ne), token_name: e2.Opt(e2.Text) }), ut = e2.Record({ id: e2.Opt(e2.Principal) }), dt = e2.Record({ dissolve_delay_interval: e2.Opt(w2), count: e2.Opt(e2.Nat64) }), pt = e2.Record({ seconds_after_utc_midnight: e2.Opt(e2.Nat64) }), lt = e2.Record({ iso_codes: e2.Vec(e2.Text) }), _t = e2.Record({ minimum_participants: e2.Opt(e2.Nat64), duration: e2.Opt(w2), neuron_basket_construction_parameters: e2.Opt(dt), confirmation_text: e2.Opt(e2.Text), maximum_participant_icp: e2.Opt(N4), minimum_icp: e2.Opt(N4), minimum_participant_icp: e2.Opt(N4), start_time: e2.Opt(pt), maximum_icp: e2.Opt(N4), neurons_fund_investment_icp: e2.Opt(N4), restricted_countries: e2.Opt(lt) }), ye2 = e2.Record({ total: e2.Opt(N4) }), mt = e2.Record({ controller: e2.Opt(e2.Principal), dissolve_delay: e2.Opt(w2), memo: e2.Opt(e2.Nat64), vesting_period: e2.Opt(w2), stake: e2.Opt(N4) }), ft = e2.Record({ developer_neurons: e2.Vec(mt) }), wt = e2.Record({ treasury_distribution: e2.Opt(ye2), developer_distribution: e2.Opt(ft), swap_distribution: e2.Opt(ye2) }), Nt = e2.Record({ url: e2.Opt(e2.Text), governance_parameters: e2.Opt(st), fallback_controller_principal_ids: e2.Vec(e2.Principal), logo: e2.Opt(Ne), name: e2.Opt(e2.Text), ledger_parameters: e2.Opt(ct), description: e2.Opt(e2.Text), dapp_canisters: e2.Vec(ut), swap_parameters: e2.Opt(_t), initial_token_distribution: e2.Opt(wt) }), yt = e2.Record({ nns_function: e2.Int32, payload: e2.Vec(e2.Nat8) }), gt = e2.Record({ dissolve_delay_interval_seconds: e2.Nat64, count: e2.Nat64 }), Rt = e2.Record({ min_participant_icp_e8s: e2.Nat64, neuron_basket_construction_parameters: e2.Opt(gt), max_icp_e8s: e2.Nat64, swap_due_timestamp_seconds: e2.Nat64, min_participants: e2.Nat32, sns_token_e8s: e2.Nat64, sale_delay_seconds: e2.Opt(e2.Nat64), max_participant_icp_e8s: e2.Nat64, min_icp_e8s: e2.Nat64 }), vt = e2.Record({ community_fund_investment_e8s: e2.Opt(e2.Nat64), target_swap_canister_id: e2.Opt(e2.Principal), params: e2.Opt(Rt) }), ht = e2.Record({ start_timestamp_seconds: e2.Nat64, end_timestamp_seconds: e2.Nat64 }), Ot = e2.Record({ open_time_window: e2.Opt(ht) }), St = e2.Record({ request: e2.Opt(Ot), swap_canister_id: e2.Opt(e2.Principal) }), bt = e2.Record({ default_followees: e2.Vec(e2.Tuple(e2.Int32, o5)) }), ge = e2.Record({ use_registry_derived_rewards: e2.Opt(e2.Bool), rewards: e2.Vec(m4) }), xt = e2.Record({ principals: e2.Vec(e2.Principal) }), kt = e2.Variant({ ToRemove: a, ToAdd: a }), Tt = e2.Record({ change: e2.Opt(kt) }), Ct = e2.Record({ motion_text: e2.Text }), Pt = e2.Variant({ RegisterKnownNeuron: ue, ManageNeuron: Z3, CreateServiceNervousSystem: Nt, ExecuteNnsFunction: yt, RewardNodeProvider: m4, OpenSnsTokenSwap: vt, SetSnsTokenSwapOpenTimeWindow: St, SetDefaultFollowees: bt, RewardNodeProviders: ge, ManageNetworkEconomics: y, ApproveGenesisKyc: xt, AddOrRemoveNodeProvider: Tt, Motion: Ct });
  t3.fill(e2.Record({ url: e2.Text, title: e2.Opt(e2.Text), action: e2.Opt(Pt), summary: e2.Text }));
  let Mt = e2.Record({ current_deadline_timestamp_seconds: e2.Nat64 }), At = e2.Record({ id: e2.Opt(n2), failure_reason: e2.Opt(l3), cf_participants: e2.Vec(ze), ballots: e2.Vec(e2.Tuple(e2.Nat64, ie)), proposal_timestamp_seconds: e2.Nat64, reward_event_round: e2.Nat64, failed_timestamp_seconds: e2.Nat64, reject_cost_e8s: e2.Nat64, derived_proposal_information: e2.Opt(se2), latest_tally: e2.Opt(ce3), sns_token_swap_lifecycle: e2.Opt(e2.Int32), decided_timestamp_seconds: e2.Nat64, proposal: e2.Opt(t3), proposer: e2.Opt(n2), wait_for_quiet_state: e2.Opt(Mt), executed_timestamp_seconds: e2.Nat64, original_total_community_fund_maturity_e8s_equivalent: e2.Opt(e2.Nat64) }), Vt = e2.Variant({ Spawn: n2, Split: de, Configure: _e, Merge: u3, DisburseToNeuron: me, SyncCommand: e2.Record({}), ClaimOrRefreshNeuron: le, MergeMaturity: fe2, Disburse: we2 }), Et = e2.Record({ command: e2.Opt(Vt), timestamp: e2.Nat64 }), Re = e2.Record({ vote: e2.Int32, proposal_id: e2.Opt(n2) }), Ft = e2.Variant({ DissolveDelaySeconds: e2.Nat64, WhenDissolvedTimestampSeconds: e2.Nat64 }), C2 = e2.Record({ id: e2.Opt(n2), staked_maturity_e8s_equivalent: e2.Opt(e2.Nat64), controller: e2.Opt(e2.Principal), recent_ballots: e2.Vec(Re), kyc_verified: e2.Bool, not_for_profit: e2.Bool, maturity_e8s_equivalent: e2.Nat64, cached_neuron_stake_e8s: e2.Nat64, created_timestamp_seconds: e2.Nat64, auto_stake_maturity: e2.Opt(e2.Bool), aging_since_timestamp_seconds: e2.Nat64, hot_keys: e2.Vec(e2.Principal), account: e2.Vec(e2.Nat8), joined_community_fund_timestamp_seconds: e2.Opt(e2.Nat64), dissolve_state: e2.Opt(Ft), followees: e2.Vec(e2.Tuple(e2.Int32, o5)), neuron_fees_e8s: e2.Nat64, transfer: e2.Opt(k4), known_neuron_data: e2.Opt(Y3), spawn_at_timestamp_seconds: e2.Opt(e2.Nat64) }), or = e2.Record({ default_followees: e2.Vec(e2.Tuple(e2.Int32, o5)), most_recent_monthly_node_provider_rewards: e2.Opt(f2), maturity_modulation_last_updated_at_timestamp_seconds: e2.Opt(e2.Nat64), wait_for_quiet_threshold_seconds: e2.Nat64, metrics: e2.Opt(_4), node_providers: e2.Vec(a), cached_daily_maturity_modulation_basis_points: e2.Opt(e2.Int32), economics: e2.Opt(y), spawning_neurons: e2.Opt(e2.Bool), latest_reward_event: e2.Opt(g3), to_claim_transfers: e2.Vec(k4), short_voting_period_seconds: e2.Nat64, proposals: e2.Vec(e2.Tuple(e2.Nat64, At)), in_flight_commands: e2.Vec(e2.Tuple(e2.Nat64, Et)), neurons: e2.Vec(e2.Tuple(e2.Nat64, C2)), genesis_timestamp_seconds: e2.Nat64 }), H2 = e2.Variant({ Ok: e2.Null, Err: l3 }), Bt = e2.Variant({ Error: l3, NeuronId: n2 }), qt = e2.Record({ result: e2.Opt(Bt) }), ve = e2.Variant({ Ok: C2, Err: l3 }), Ut = e2.Variant({ Ok: _4, Err: l3 }), Kt = e2.Variant({ Ok: ge, Err: l3 }), W = e2.Record({ dissolve_delay_seconds: e2.Nat64, recent_ballots: e2.Vec(Re), created_timestamp_seconds: e2.Nat64, state: e2.Int32, stake_e8s: e2.Nat64, joined_community_fund_timestamp_seconds: e2.Opt(e2.Nat64), retrieved_at_timestamp_seconds: e2.Nat64, known_neuron_data: e2.Opt(Y3), voting_power: e2.Nat64, age_seconds: e2.Nat64 }), he = e2.Variant({ Ok: W, Err: l3 }), Ht = e2.Variant({ Ok: a, Err: l3 }), I2 = e2.Record({ id: e2.Opt(n2), status: e2.Int32, topic: e2.Int32, failure_reason: e2.Opt(l3), ballots: e2.Vec(e2.Tuple(e2.Nat64, ie)), proposal_timestamp_seconds: e2.Nat64, reward_event_round: e2.Nat64, deadline_timestamp_seconds: e2.Opt(e2.Nat64), failed_timestamp_seconds: e2.Nat64, reject_cost_e8s: e2.Nat64, derived_proposal_information: e2.Opt(se2), latest_tally: e2.Opt(ce3), reward_status: e2.Int32, decided_timestamp_seconds: e2.Nat64, proposal: e2.Opt(t3), proposer: e2.Opt(n2), executed_timestamp_seconds: e2.Nat64 }), Wt = e2.Record({ known_neurons: e2.Vec(ue) }), Gt = e2.Record({ neuron_ids: e2.Vec(e2.Nat64), include_neurons_readable_by_caller: e2.Bool }), jt = e2.Record({ neuron_infos: e2.Vec(e2.Tuple(e2.Nat64, W)), full_neurons: e2.Vec(C2) }), zt = e2.Record({ node_providers: e2.Vec(a) }), Jt = e2.Record({ include_reward_status: e2.Vec(e2.Int32), before_proposal: e2.Opt(n2), limit: e2.Nat32, exclude_topic: e2.Vec(e2.Int32), include_all_manage_neuron_proposals: e2.Opt(e2.Bool), include_status: e2.Vec(e2.Int32) }), $t = e2.Record({ proposal_info: e2.Vec(I2) }), D = e2.Record({ created_neuron_id: e2.Opt(n2) }), Xt = e2.Record({ refreshed_neuron_id: e2.Opt(n2) }), Yt = e2.Record({ target_neuron: e2.Opt(C2), source_neuron: e2.Opt(C2), target_neuron_info: e2.Opt(W), source_neuron_info: e2.Opt(W) }), Qt = e2.Record({ proposal_id: e2.Opt(n2) }), Zt = e2.Record({ maturity_e8s: e2.Nat64, staked_maturity_e8s: e2.Nat64 }), It = e2.Record({ merged_maturity_e8s: e2.Nat64, new_stake_e8s: e2.Nat64 }), Dt = e2.Record({ transfer_block_height: e2.Nat64 }), Lt = e2.Variant({ Error: l3, Spawn: D, Split: D, Follow: e2.Record({}), ClaimOrRefresh: Xt, Configure: e2.Record({}), RegisterVote: e2.Record({}), Merge: Yt, DisburseToNeuron: D, MakeProposal: Qt, StakeMaturity: Zt, MergeMaturity: It, Disburse: Dt }), Oe = e2.Record({ command: e2.Opt(Lt) }), en = e2.Record({ sns_governance_canister_id: e2.Opt(e2.Principal) }), tn = e2.Variant({ Committed: en, Aborted: e2.Record({}) }), nn = e2.Record({ result: e2.Opt(tn), open_sns_token_swap_proposal_id: e2.Opt(e2.Nat64) }), on = e2.Record({ reward_account: e2.Opt(r) });
  return e2.Service({ claim_gtc_neurons: e2.Func([e2.Principal, e2.Vec(n2)], [H2], []), claim_or_refresh_neuron_from_account: e2.Func([pe], [qt], []), get_build_metadata: e2.Func([], [e2.Text], []), get_full_neuron: e2.Func([e2.Nat64], [ve], []), get_full_neuron_by_id_or_subaccount: e2.Func([Q], [ve], []), get_latest_reward_event: e2.Func([], [g3], []), get_metrics: e2.Func([], [Ut], []), get_monthly_node_provider_rewards: e2.Func([], [Kt], []), get_most_recent_monthly_node_provider_rewards: e2.Func([], [e2.Opt(f2)], []), get_network_economics_parameters: e2.Func([], [y], []), get_neuron_ids: e2.Func([], [e2.Vec(e2.Nat64)], []), get_neuron_info: e2.Func([e2.Nat64], [he], []), get_neuron_info_by_id_or_subaccount: e2.Func([Q], [he], []), get_node_provider_by_caller: e2.Func([e2.Null], [Ht], []), get_pending_proposals: e2.Func([], [e2.Vec(I2)], []), get_proposal_info: e2.Func([e2.Nat64], [e2.Opt(I2)], []), list_known_neurons: e2.Func([], [Wt], []), list_neurons: e2.Func([Gt], [jt], []), list_node_providers: e2.Func([], [zt], []), list_proposals: e2.Func([Jt], [$t], []), manage_neuron: e2.Func([Z3], [Oe], []), settle_community_fund_participation: e2.Func([nn], [H2], []), simulate_manage_neuron: e2.Func([Z3], [Oe], []), transfer_gtc_neuron: e2.Func([n2, n2], [H2], []), update_node_provider: e2.Func([on], [H2], []) });
};
var eo = ({ IDL: e2 }) => {
  let t3 = e2.Rec(), n2 = e2.Record({ id: e2.Nat64 }), o5 = e2.Record({ followees: e2.Vec(n2) }), r = e2.Record({ hash: e2.Vec(e2.Nat8) }), a = e2.Record({ id: e2.Opt(e2.Principal), reward_account: e2.Opt(r) }), i2 = e2.Record({ dissolve_delay_seconds: e2.Nat64 }), c3 = e2.Record({ to_account: e2.Opt(r) }), d4 = e2.Variant({ RewardToNeuron: i2, RewardToAccount: c3 }), m4 = e2.Record({ node_provider: e2.Opt(a), reward_mode: e2.Opt(d4), amount_e8s: e2.Nat64 }), f2 = e2.Record({ timestamp: e2.Nat64, rewards: e2.Vec(m4) }), _4 = e2.Record({ not_dissolving_neurons_e8s_buckets: e2.Vec(e2.Tuple(e2.Nat64, e2.Float64)), garbage_collectable_neurons_count: e2.Nat64, neurons_with_invalid_stake_count: e2.Nat64, not_dissolving_neurons_count_buckets: e2.Vec(e2.Tuple(e2.Nat64, e2.Nat64)), total_supply_icp: e2.Nat64, neurons_with_less_than_6_months_dissolve_delay_count: e2.Nat64, dissolved_neurons_count: e2.Nat64, community_fund_total_maturity_e8s_equivalent: e2.Nat64, total_staked_e8s: e2.Nat64, not_dissolving_neurons_count: e2.Nat64, total_locked_e8s: e2.Nat64, dissolved_neurons_e8s: e2.Nat64, neurons_with_less_than_6_months_dissolve_delay_e8s: e2.Nat64, dissolving_neurons_count_buckets: e2.Vec(e2.Tuple(e2.Nat64, e2.Nat64)), dissolving_neurons_count: e2.Nat64, dissolving_neurons_e8s_buckets: e2.Vec(e2.Tuple(e2.Nat64, e2.Float64)), community_fund_total_staked_e8s: e2.Nat64, timestamp_seconds: e2.Nat64 }), y = e2.Record({ neuron_minimum_stake_e8s: e2.Nat64, max_proposals_to_keep_per_topic: e2.Nat32, neuron_management_fee_per_proposal_e8s: e2.Nat64, reject_cost_e8s: e2.Nat64, transaction_fee_e8s: e2.Nat64, neuron_spawn_dissolve_delay_seconds: e2.Nat64, minimum_icp_xdr_rate: e2.Nat64, maximum_node_provider_rewards_e8s: e2.Nat64 }), g3 = e2.Record({ rounds_since_last_distribution: e2.Opt(e2.Nat64), day_after_genesis: e2.Nat64, actual_timestamp_seconds: e2.Nat64, total_available_e8s_equivalent: e2.Nat64, latest_round_available_e8s_equivalent: e2.Opt(e2.Nat64), distributed_e8s_equivalent: e2.Nat64, settled_proposals: e2.Vec(n2) }), k4 = e2.Record({ to_subaccount: e2.Vec(e2.Nat8), neuron_stake_e8s: e2.Nat64, from: e2.Opt(e2.Principal), memo: e2.Nat64, from_subaccount: e2.Vec(e2.Nat8), transfer_timestamp: e2.Nat64, block_height: e2.Nat64 }), l3 = e2.Record({ error_message: e2.Text, error_type: e2.Int32 }), je = e2.Record({ nns_neuron_id: e2.Nat64, amount_icp_e8s: e2.Nat64 }), ze = e2.Record({ hotkey_principal: e2.Text, cf_neurons: e2.Vec(je) }), ie = e2.Record({ vote: e2.Int32, voting_power: e2.Nat64 }), Je = e2.Record({ status: e2.Opt(e2.Int32), freezing_threshold: e2.Opt(e2.Nat64), controllers: e2.Vec(e2.Principal), memory_size: e2.Opt(e2.Nat64), cycles: e2.Opt(e2.Nat64), idle_cycles_burned_per_day: e2.Opt(e2.Nat64), module_hash: e2.Vec(e2.Nat8) }), O = e2.Record({ status: e2.Opt(Je), canister_id: e2.Opt(e2.Principal) }), $e = e2.Record({ ledger_index_canister_summary: e2.Opt(O), fallback_controller_principal_ids: e2.Vec(e2.Principal), ledger_archive_canister_summaries: e2.Vec(O), ledger_canister_summary: e2.Opt(O), swap_canister_summary: e2.Opt(O), governance_canister_summary: e2.Opt(O), root_canister_summary: e2.Opt(O), dapp_canister_summaries: e2.Vec(O) }), se2 = e2.Record({ swap_background_information: e2.Opt($e) }), ce3 = e2.Record({ no: e2.Nat64, yes: e2.Nat64, total: e2.Nat64, timestamp_seconds: e2.Nat64 }), Y3 = e2.Record({ name: e2.Text, description: e2.Opt(e2.Text) }), ue = e2.Record({ id: e2.Opt(n2), known_neuron_data: e2.Opt(Y3) }), Xe = e2.Record({ percentage_to_spawn: e2.Opt(e2.Nat32), new_controller: e2.Opt(e2.Principal), nonce: e2.Opt(e2.Nat64) }), de = e2.Record({ amount_e8s: e2.Nat64 }), Ye = e2.Record({ topic: e2.Int32, followees: e2.Vec(n2) }), pe = e2.Record({ controller: e2.Opt(e2.Principal), memo: e2.Nat64 }), Qe = e2.Variant({ NeuronIdOrSubaccount: e2.Record({}), MemoAndController: pe, Memo: e2.Nat64 }), le = e2.Record({ by: e2.Opt(Qe) }), Ze = e2.Record({ hot_key_to_remove: e2.Opt(e2.Principal) }), Ie = e2.Record({ new_hot_key: e2.Opt(e2.Principal) }), De = e2.Record({ requested_setting_for_auto_stake_maturity: e2.Bool }), Le = e2.Record({ additional_dissolve_delay_seconds: e2.Nat32 }), et = e2.Record({ dissolve_timestamp_seconds: e2.Nat64 }), tt2 = e2.Variant({ RemoveHotKey: Ze, AddHotKey: Ie, ChangeAutoStakeMaturity: De, StopDissolving: e2.Record({}), StartDissolving: e2.Record({}), IncreaseDissolveDelay: Le, JoinCommunityFund: e2.Record({}), LeaveCommunityFund: e2.Record({}), SetDissolveTimestamp: et }), _e = e2.Record({ operation: e2.Opt(tt2) }), nt = e2.Record({ vote: e2.Int32, proposal: e2.Opt(n2) }), u3 = e2.Record({ source_neuron_id: e2.Opt(n2) }), me = e2.Record({ dissolve_delay_seconds: e2.Nat64, kyc_verified: e2.Bool, amount_e8s: e2.Nat64, new_controller: e2.Opt(e2.Principal), nonce: e2.Nat64 }), ot = e2.Record({ percentage_to_stake: e2.Opt(e2.Nat32) }), fe2 = e2.Record({ percentage_to_merge: e2.Nat32 }), rt = e2.Record({ e8s: e2.Nat64 }), we2 = e2.Record({ to_account: e2.Opt(r), amount: e2.Opt(rt) }), at = e2.Variant({ Spawn: Xe, Split: de, Follow: Ye, ClaimOrRefresh: le, Configure: _e, RegisterVote: nt, Merge: u3, DisburseToNeuron: me, MakeProposal: t3, StakeMaturity: ot, MergeMaturity: fe2, Disburse: we2 }), Q = e2.Variant({ Subaccount: e2.Vec(e2.Nat8), NeuronId: n2 }), Z3 = e2.Record({ id: e2.Opt(n2), command: e2.Opt(at), neuron_id_or_subaccount: e2.Opt(Q) }), K3 = e2.Record({ basis_points: e2.Opt(e2.Nat64) }), w2 = e2.Record({ seconds: e2.Opt(e2.Nat64) }), N4 = e2.Record({ e8s: e2.Opt(e2.Nat64) }), it = e2.Record({ reward_rate_transition_duration: e2.Opt(w2), initial_reward_rate: e2.Opt(K3), final_reward_rate: e2.Opt(K3) }), st = e2.Record({ neuron_maximum_dissolve_delay_bonus: e2.Opt(K3), neuron_maximum_age_for_age_bonus: e2.Opt(w2), neuron_maximum_dissolve_delay: e2.Opt(w2), neuron_minimum_dissolve_delay_to_vote: e2.Opt(w2), neuron_maximum_age_bonus: e2.Opt(K3), neuron_minimum_stake: e2.Opt(N4), proposal_wait_for_quiet_deadline_increase: e2.Opt(w2), proposal_initial_voting_period: e2.Opt(w2), proposal_rejection_fee: e2.Opt(N4), voting_reward_parameters: e2.Opt(it) }), Ne = e2.Record({ base64_encoding: e2.Opt(e2.Text) }), ct = e2.Record({ transaction_fee: e2.Opt(N4), token_symbol: e2.Opt(e2.Text), token_logo: e2.Opt(Ne), token_name: e2.Opt(e2.Text) }), ut = e2.Record({ id: e2.Opt(e2.Principal) }), dt = e2.Record({ dissolve_delay_interval: e2.Opt(w2), count: e2.Opt(e2.Nat64) }), pt = e2.Record({ seconds_after_utc_midnight: e2.Opt(e2.Nat64) }), lt = e2.Record({ iso_codes: e2.Vec(e2.Text) }), _t = e2.Record({ minimum_participants: e2.Opt(e2.Nat64), duration: e2.Opt(w2), neuron_basket_construction_parameters: e2.Opt(dt), confirmation_text: e2.Opt(e2.Text), maximum_participant_icp: e2.Opt(N4), minimum_icp: e2.Opt(N4), minimum_participant_icp: e2.Opt(N4), start_time: e2.Opt(pt), maximum_icp: e2.Opt(N4), neurons_fund_investment_icp: e2.Opt(N4), restricted_countries: e2.Opt(lt) }), ye2 = e2.Record({ total: e2.Opt(N4) }), mt = e2.Record({ controller: e2.Opt(e2.Principal), dissolve_delay: e2.Opt(w2), memo: e2.Opt(e2.Nat64), vesting_period: e2.Opt(w2), stake: e2.Opt(N4) }), ft = e2.Record({ developer_neurons: e2.Vec(mt) }), wt = e2.Record({ treasury_distribution: e2.Opt(ye2), developer_distribution: e2.Opt(ft), swap_distribution: e2.Opt(ye2) }), Nt = e2.Record({ url: e2.Opt(e2.Text), governance_parameters: e2.Opt(st), fallback_controller_principal_ids: e2.Vec(e2.Principal), logo: e2.Opt(Ne), name: e2.Opt(e2.Text), ledger_parameters: e2.Opt(ct), description: e2.Opt(e2.Text), dapp_canisters: e2.Vec(ut), swap_parameters: e2.Opt(_t), initial_token_distribution: e2.Opt(wt) }), yt = e2.Record({ nns_function: e2.Int32, payload: e2.Vec(e2.Nat8) }), gt = e2.Record({ dissolve_delay_interval_seconds: e2.Nat64, count: e2.Nat64 }), Rt = e2.Record({ min_participant_icp_e8s: e2.Nat64, neuron_basket_construction_parameters: e2.Opt(gt), max_icp_e8s: e2.Nat64, swap_due_timestamp_seconds: e2.Nat64, min_participants: e2.Nat32, sns_token_e8s: e2.Nat64, sale_delay_seconds: e2.Opt(e2.Nat64), max_participant_icp_e8s: e2.Nat64, min_icp_e8s: e2.Nat64 }), vt = e2.Record({ community_fund_investment_e8s: e2.Opt(e2.Nat64), target_swap_canister_id: e2.Opt(e2.Principal), params: e2.Opt(Rt) }), ht = e2.Record({ start_timestamp_seconds: e2.Nat64, end_timestamp_seconds: e2.Nat64 }), Ot = e2.Record({ open_time_window: e2.Opt(ht) }), St = e2.Record({ request: e2.Opt(Ot), swap_canister_id: e2.Opt(e2.Principal) }), bt = e2.Record({ default_followees: e2.Vec(e2.Tuple(e2.Int32, o5)) }), ge = e2.Record({ use_registry_derived_rewards: e2.Opt(e2.Bool), rewards: e2.Vec(m4) }), xt = e2.Record({ principals: e2.Vec(e2.Principal) }), kt = e2.Variant({ ToRemove: a, ToAdd: a }), Tt = e2.Record({ change: e2.Opt(kt) }), Ct = e2.Record({ motion_text: e2.Text }), Pt = e2.Variant({ RegisterKnownNeuron: ue, ManageNeuron: Z3, CreateServiceNervousSystem: Nt, ExecuteNnsFunction: yt, RewardNodeProvider: m4, OpenSnsTokenSwap: vt, SetSnsTokenSwapOpenTimeWindow: St, SetDefaultFollowees: bt, RewardNodeProviders: ge, ManageNetworkEconomics: y, ApproveGenesisKyc: xt, AddOrRemoveNodeProvider: Tt, Motion: Ct });
  t3.fill(e2.Record({ url: e2.Text, title: e2.Opt(e2.Text), action: e2.Opt(Pt), summary: e2.Text }));
  let Mt = e2.Record({ current_deadline_timestamp_seconds: e2.Nat64 }), At = e2.Record({ id: e2.Opt(n2), failure_reason: e2.Opt(l3), cf_participants: e2.Vec(ze), ballots: e2.Vec(e2.Tuple(e2.Nat64, ie)), proposal_timestamp_seconds: e2.Nat64, reward_event_round: e2.Nat64, failed_timestamp_seconds: e2.Nat64, reject_cost_e8s: e2.Nat64, derived_proposal_information: e2.Opt(se2), latest_tally: e2.Opt(ce3), sns_token_swap_lifecycle: e2.Opt(e2.Int32), decided_timestamp_seconds: e2.Nat64, proposal: e2.Opt(t3), proposer: e2.Opt(n2), wait_for_quiet_state: e2.Opt(Mt), executed_timestamp_seconds: e2.Nat64, original_total_community_fund_maturity_e8s_equivalent: e2.Opt(e2.Nat64) }), Vt = e2.Variant({ Spawn: n2, Split: de, Configure: _e, Merge: u3, DisburseToNeuron: me, SyncCommand: e2.Record({}), ClaimOrRefreshNeuron: le, MergeMaturity: fe2, Disburse: we2 }), Et = e2.Record({ command: e2.Opt(Vt), timestamp: e2.Nat64 }), Re = e2.Record({ vote: e2.Int32, proposal_id: e2.Opt(n2) }), Ft = e2.Variant({ DissolveDelaySeconds: e2.Nat64, WhenDissolvedTimestampSeconds: e2.Nat64 }), C2 = e2.Record({ id: e2.Opt(n2), staked_maturity_e8s_equivalent: e2.Opt(e2.Nat64), controller: e2.Opt(e2.Principal), recent_ballots: e2.Vec(Re), kyc_verified: e2.Bool, not_for_profit: e2.Bool, maturity_e8s_equivalent: e2.Nat64, cached_neuron_stake_e8s: e2.Nat64, created_timestamp_seconds: e2.Nat64, auto_stake_maturity: e2.Opt(e2.Bool), aging_since_timestamp_seconds: e2.Nat64, hot_keys: e2.Vec(e2.Principal), account: e2.Vec(e2.Nat8), joined_community_fund_timestamp_seconds: e2.Opt(e2.Nat64), dissolve_state: e2.Opt(Ft), followees: e2.Vec(e2.Tuple(e2.Int32, o5)), neuron_fees_e8s: e2.Nat64, transfer: e2.Opt(k4), known_neuron_data: e2.Opt(Y3), spawn_at_timestamp_seconds: e2.Opt(e2.Nat64) }), or = e2.Record({ default_followees: e2.Vec(e2.Tuple(e2.Int32, o5)), most_recent_monthly_node_provider_rewards: e2.Opt(f2), maturity_modulation_last_updated_at_timestamp_seconds: e2.Opt(e2.Nat64), wait_for_quiet_threshold_seconds: e2.Nat64, metrics: e2.Opt(_4), node_providers: e2.Vec(a), cached_daily_maturity_modulation_basis_points: e2.Opt(e2.Int32), economics: e2.Opt(y), spawning_neurons: e2.Opt(e2.Bool), latest_reward_event: e2.Opt(g3), to_claim_transfers: e2.Vec(k4), short_voting_period_seconds: e2.Nat64, proposals: e2.Vec(e2.Tuple(e2.Nat64, At)), in_flight_commands: e2.Vec(e2.Tuple(e2.Nat64, Et)), neurons: e2.Vec(e2.Tuple(e2.Nat64, C2)), genesis_timestamp_seconds: e2.Nat64 }), H2 = e2.Variant({ Ok: e2.Null, Err: l3 }), Bt = e2.Variant({ Error: l3, NeuronId: n2 }), qt = e2.Record({ result: e2.Opt(Bt) }), ve = e2.Variant({ Ok: C2, Err: l3 }), Ut = e2.Variant({ Ok: _4, Err: l3 }), Kt = e2.Variant({ Ok: ge, Err: l3 }), W = e2.Record({ dissolve_delay_seconds: e2.Nat64, recent_ballots: e2.Vec(Re), created_timestamp_seconds: e2.Nat64, state: e2.Int32, stake_e8s: e2.Nat64, joined_community_fund_timestamp_seconds: e2.Opt(e2.Nat64), retrieved_at_timestamp_seconds: e2.Nat64, known_neuron_data: e2.Opt(Y3), voting_power: e2.Nat64, age_seconds: e2.Nat64 }), he = e2.Variant({ Ok: W, Err: l3 }), Ht = e2.Variant({ Ok: a, Err: l3 }), I2 = e2.Record({ id: e2.Opt(n2), status: e2.Int32, topic: e2.Int32, failure_reason: e2.Opt(l3), ballots: e2.Vec(e2.Tuple(e2.Nat64, ie)), proposal_timestamp_seconds: e2.Nat64, reward_event_round: e2.Nat64, deadline_timestamp_seconds: e2.Opt(e2.Nat64), failed_timestamp_seconds: e2.Nat64, reject_cost_e8s: e2.Nat64, derived_proposal_information: e2.Opt(se2), latest_tally: e2.Opt(ce3), reward_status: e2.Int32, decided_timestamp_seconds: e2.Nat64, proposal: e2.Opt(t3), proposer: e2.Opt(n2), executed_timestamp_seconds: e2.Nat64 }), Wt = e2.Record({ known_neurons: e2.Vec(ue) }), Gt = e2.Record({ neuron_ids: e2.Vec(e2.Nat64), include_neurons_readable_by_caller: e2.Bool }), jt = e2.Record({ neuron_infos: e2.Vec(e2.Tuple(e2.Nat64, W)), full_neurons: e2.Vec(C2) }), zt = e2.Record({ node_providers: e2.Vec(a) }), Jt = e2.Record({ include_reward_status: e2.Vec(e2.Int32), before_proposal: e2.Opt(n2), limit: e2.Nat32, exclude_topic: e2.Vec(e2.Int32), include_all_manage_neuron_proposals: e2.Opt(e2.Bool), include_status: e2.Vec(e2.Int32) }), $t = e2.Record({ proposal_info: e2.Vec(I2) }), D = e2.Record({ created_neuron_id: e2.Opt(n2) }), Xt = e2.Record({ refreshed_neuron_id: e2.Opt(n2) }), Yt = e2.Record({ target_neuron: e2.Opt(C2), source_neuron: e2.Opt(C2), target_neuron_info: e2.Opt(W), source_neuron_info: e2.Opt(W) }), Qt = e2.Record({ proposal_id: e2.Opt(n2) }), Zt = e2.Record({ maturity_e8s: e2.Nat64, staked_maturity_e8s: e2.Nat64 }), It = e2.Record({ merged_maturity_e8s: e2.Nat64, new_stake_e8s: e2.Nat64 }), Dt = e2.Record({ transfer_block_height: e2.Nat64 }), Lt = e2.Variant({ Error: l3, Spawn: D, Split: D, Follow: e2.Record({}), ClaimOrRefresh: Xt, Configure: e2.Record({}), RegisterVote: e2.Record({}), Merge: Yt, DisburseToNeuron: D, MakeProposal: Qt, StakeMaturity: Zt, MergeMaturity: It, Disburse: Dt }), Oe = e2.Record({ command: e2.Opt(Lt) }), en = e2.Record({ sns_governance_canister_id: e2.Opt(e2.Principal) }), tn = e2.Variant({ Committed: en, Aborted: e2.Record({}) }), nn = e2.Record({ result: e2.Opt(tn), open_sns_token_swap_proposal_id: e2.Opt(e2.Nat64) }), on = e2.Record({ reward_account: e2.Opt(r) });
  return e2.Service({ claim_gtc_neurons: e2.Func([e2.Principal, e2.Vec(n2)], [H2], []), claim_or_refresh_neuron_from_account: e2.Func([pe], [qt], []), get_build_metadata: e2.Func([], [e2.Text], ["query"]), get_full_neuron: e2.Func([e2.Nat64], [ve], ["query"]), get_full_neuron_by_id_or_subaccount: e2.Func([Q], [ve], ["query"]), get_latest_reward_event: e2.Func([], [g3], ["query"]), get_metrics: e2.Func([], [Ut], ["query"]), get_monthly_node_provider_rewards: e2.Func([], [Kt], []), get_most_recent_monthly_node_provider_rewards: e2.Func([], [e2.Opt(f2)], ["query"]), get_network_economics_parameters: e2.Func([], [y], ["query"]), get_neuron_ids: e2.Func([], [e2.Vec(e2.Nat64)], ["query"]), get_neuron_info: e2.Func([e2.Nat64], [he], ["query"]), get_neuron_info_by_id_or_subaccount: e2.Func([Q], [he], ["query"]), get_node_provider_by_caller: e2.Func([e2.Null], [Ht], ["query"]), get_pending_proposals: e2.Func([], [e2.Vec(I2)], ["query"]), get_proposal_info: e2.Func([e2.Nat64], [e2.Opt(I2)], ["query"]), list_known_neurons: e2.Func([], [Wt], ["query"]), list_neurons: e2.Func([Gt], [jt], ["query"]), list_node_providers: e2.Func([], [zt], ["query"]), list_proposals: e2.Func([Jt], [$t], ["query"]), manage_neuron: e2.Func([Z3], [Oe], []), settle_community_fund_participation: e2.Func([nn], [H2], []), simulate_manage_neuron: e2.Func([Z3], [Oe], []), transfer_gtc_neuron: e2.Func([n2, n2], [H2], []), update_node_provider: e2.Func([on], [H2], []) });
};
var Ee = class extends Error {
};
var Fe = class extends Ee {
};
var Be2 = class extends Ee {
  constructor(n2) {
    super();
    this.minimumAmount = n2;
  }
};
var z = class extends Error {
};
var P3 = class extends Error {
  constructor(n2) {
    super();
    this.detail = n2;
  }
};
var be = class extends Error {
};
var v2 = class extends Error {
  constructor(t3) {
    super("Unsupported value: " + t3);
  }
};
var qe = class extends Error {
};
var yn = o2(mn());
var to = (e2) => Uint8Array.from(yn.Buffer.from(e2, "hex")).subarray(4);
var no = (e2) => yn.Buffer.from(e2).toString("hex");
var oo = (e2, t3) => {
  let n2 = se(`
account-id`), o5 = S.create();
  o5.update(xe([...n2, ...e2.toUint8Array(), ...t3 ?? Array(32).fill(0)]));
  let r = o5.digest(), a = ye(r), i2 = new Uint8Array([...a, ...r]);
  return fe(i2);
};
var io = (e2) => ({ id: e2 });
var gn = (e2) => ({ id: e2 });
var jr = (e2) => ({ followees: e2.map(gn) });
var zr = (e2) => {
  if ("NeuronId" in e2)
    return { NeuronId: { id: e2.NeuronId } };
  if ("Subaccount" in e2)
    return { Subaccount: Uint8Array.from(e2.Subaccount) };
  throw new v2(e2);
};
var Ue = (e2) => e2.basisPoints !== void 0 ? { basis_points: [e2.basisPoints] } : { basis_points: [] };
var E4 = (e2) => e2.seconds !== void 0 ? { seconds: [e2.seconds] } : { seconds: [] };
var Jr = (e2) => e2.secondsAfterUtcMidnight !== void 0 ? { seconds_after_utc_midnight: [e2.secondsAfterUtcMidnight] } : { seconds_after_utc_midnight: [] };
var $r = (e2) => ({ iso_codes: e2.isoCodes });
var F2 = (e2) => e2.e8s !== void 0 ? { e8s: [e2.e8s] } : { e8s: [] };
var so = (e2) => e2.base64Encoding !== void 0 ? { base64_encoding: [e2.base64Encoding] } : { base64_encoding: [] };
var Xr = (e2) => ({ reward_rate_transition_duration: e2.rewardRateTransitionDuration !== void 0 ? [E4(e2.rewardRateTransitionDuration)] : [], initial_reward_rate: e2.initialRewardRate !== void 0 ? [Ue(e2.initialRewardRate)] : [], final_reward_rate: e2.finalRewardRate !== void 0 ? [Ue(e2.finalRewardRate)] : [] });
var Yr = (e2) => ({ transaction_fee: e2.transactionFee !== void 0 ? [F2(e2.transactionFee)] : [], token_symbol: e2.tokenSymbol !== void 0 ? [e2.tokenSymbol] : [], token_logo: e2.tokenLogo !== void 0 ? [so(e2.tokenLogo)] : [], token_name: e2.tokenName !== void 0 ? [e2.tokenName] : [] });
var Qr = (e2) => ({ minimum_participants: e2.minimumParticipants !== void 0 ? [e2.minimumParticipants] : [], duration: e2.duration !== void 0 ? [E4(e2.duration)] : [], neuron_basket_construction_parameters: e2.neuronBasketConstructionParameters !== void 0 ? [Zr(e2.neuronBasketConstructionParameters)] : [], confirmation_text: e2.confirmationText !== void 0 ? [e2.confirmationText] : [], maximum_participant_icp: e2.maximumParticipantIcp !== void 0 ? [F2(e2.maximumParticipantIcp)] : [], neurons_fund_investment_icp: e2.neuronsFundInvestmentIcp !== void 0 ? [F2(e2.neuronsFundInvestmentIcp)] : [], minimum_icp: e2.minimumIcp !== void 0 ? [F2(e2.minimumIcp)] : [], minimum_participant_icp: e2.minimumParticipantIcp !== void 0 ? [F2(e2.minimumParticipantIcp)] : [], start_time: e2.startTime !== void 0 ? [Jr(e2.startTime)] : [], maximum_icp: e2.maximumIcp !== void 0 ? [F2(e2.maximumIcp)] : [], restricted_countries: e2.restrictedCountries !== void 0 ? [$r(e2.restrictedCountries)] : [] });
var Zr = (e2) => ({ dissolve_delay_interval: e2.dissolveDelayInterval !== void 0 ? [E4(e2.dissolveDelayInterval)] : [], count: e2.count !== void 0 ? [e2.count] : [] });
var Ir = (e2) => ({ neuron_maximum_dissolve_delay_bonus: e2.neuronMaximumDissolveDelayBonus !== void 0 ? [Ue(e2.neuronMaximumDissolveDelayBonus)] : [], neuron_maximum_age_for_age_bonus: e2.neuronMaximumAgeForAgeBonus !== void 0 ? [E4(e2.neuronMaximumAgeForAgeBonus)] : [], neuron_maximum_dissolve_delay: e2.neuronMaximumDissolveDelay !== void 0 ? [E4(e2.neuronMaximumDissolveDelay)] : [], neuron_minimum_dissolve_delay_to_vote: e2.neuronMinimumDissolveDelayToVote !== void 0 ? [E4(e2.neuronMinimumDissolveDelayToVote)] : [], neuron_maximum_age_bonus: e2.neuronMaximumAgeBonus !== void 0 ? [Ue(e2.neuronMaximumAgeBonus)] : [], neuron_minimum_stake: e2.neuronMinimumStake !== void 0 ? [F2(e2.neuronMinimumStake)] : [], proposal_wait_for_quiet_deadline_increase: e2.proposalWaitForQuietDeadlineIncrease !== void 0 ? [E4(e2.proposalWaitForQuietDeadlineIncrease)] : [], proposal_initial_voting_period: e2.proposalInitialVotingPeriod !== void 0 ? [E4(e2.proposalInitialVotingPeriod)] : [], proposal_rejection_fee: e2.proposalRejectionFee !== void 0 ? [F2(e2.proposalRejectionFee)] : [], voting_reward_parameters: e2.votingRewardParameters !== void 0 ? [Xr(e2.votingRewardParameters)] : [] });
var ro = (e2) => ({ total: e2.total !== void 0 ? [F2(e2.total)] : [] });
var Dr = (e2) => ({ treasury_distribution: e2.treasuryDistribution !== void 0 ? [ro(e2.treasuryDistribution)] : [], developer_distribution: e2.developerDistribution !== void 0 ? [ea(e2.developerDistribution)] : [], swap_distribution: e2.swapDistribution !== void 0 ? [ro(e2.swapDistribution)] : [] });
var Lr = (e2) => ({ controller: e2.controller !== void 0 ? [Principal.fromText(e2.controller)] : [], dissolve_delay: e2.dissolveDelay !== void 0 ? [E4(e2.dissolveDelay)] : [], memo: e2.memo !== void 0 ? [e2.memo] : [], vesting_period: e2.vestingPeriod !== void 0 ? [E4(e2.vestingPeriod)] : [], stake: e2.stake !== void 0 ? [F2(e2.stake)] : [] });
var ea = (e2) => ({ developer_neurons: e2.developerNeurons.map(Lr) });
var ta = (e2) => ({ url: e2.url !== void 0 ? [e2.url] : [], governance_parameters: e2.governanceParameters !== void 0 ? [Ir(e2.governanceParameters)] : [], fallback_controller_principal_ids: e2.fallbackControllerPrincipalIds.map(Principal.fromText), logo: e2.logo !== void 0 ? [so(e2.logo)] : [], name: e2.name !== void 0 ? [e2.name] : [], ledger_parameters: e2.ledgerParameters !== void 0 ? [Yr(e2.ledgerParameters)] : [], description: e2.description !== void 0 ? [e2.description] : [], dapp_canisters: e2.dappCanisters.map((t3) => ({ id: [Principal.fromText(t3)] })), swap_parameters: e2.swapParameters !== void 0 ? [Qr(e2.swapParameters)] : [], initial_token_distribution: e2.initialTokenDistribution !== void 0 ? [Dr(e2.initialTokenDistribution)] : [] });
var co = (e2) => {
  if ("ExecuteNnsFunction" in e2) {
    let t3 = e2.ExecuteNnsFunction;
    if (t3.payloadBytes === void 0)
      throw new Error("payloadBytes not found");
    return { ExecuteNnsFunction: { nns_function: t3.nnsFunctionId, payload: ae(t3.payloadBytes) } };
  }
  if ("ManageNeuron" in e2) {
    let t3 = e2.ManageNeuron;
    return { ManageNeuron: ia(t3) };
  }
  if ("ApproveGenesisKyc" in e2)
    return { ApproveGenesisKyc: { principals: e2.ApproveGenesisKyc.principals.map(Principal.fromText) } };
  if ("ManageNetworkEconomics" in e2) {
    let t3 = e2.ManageNetworkEconomics;
    return { ManageNetworkEconomics: { neuron_minimum_stake_e8s: t3.neuronMinimumStake, max_proposals_to_keep_per_topic: t3.maxProposalsToKeepPerTopic, neuron_management_fee_per_proposal_e8s: t3.neuronManagementFeePerProposal, reject_cost_e8s: t3.rejectCost, transaction_fee_e8s: t3.transactionFee, neuron_spawn_dissolve_delay_seconds: t3.neuronSpawnDissolveDelaySeconds, minimum_icp_xdr_rate: t3.minimumIcpXdrRate, maximum_node_provider_rewards_e8s: t3.maximumNodeProviderRewards } };
  }
  if ("RewardNodeProvider" in e2) {
    let t3 = e2.RewardNodeProvider;
    return { RewardNodeProvider: { node_provider: t3.nodeProvider ? [Ke(t3.nodeProvider)] : [], amount_e8s: t3.amountE8s, reward_mode: t3.rewardMode != null ? [ao(t3.rewardMode)] : [] } };
  }
  if ("RewardNodeProviders" in e2) {
    let t3 = e2.RewardNodeProviders;
    return { RewardNodeProviders: { use_registry_derived_rewards: t3.useRegistryDerivedRewards === void 0 ? [] : [t3.useRegistryDerivedRewards], rewards: t3.rewards.map((n2) => ({ node_provider: n2.nodeProvider ? [Ke(n2.nodeProvider)] : [], amount_e8s: n2.amountE8s, reward_mode: n2.rewardMode != null ? [ao(n2.rewardMode)] : [] })) } };
  }
  if ("AddOrRemoveNodeProvider" in e2) {
    let t3 = e2.AddOrRemoveNodeProvider;
    return { AddOrRemoveNodeProvider: { change: t3.change ? [ra(t3.change)] : [] } };
  }
  if ("Motion" in e2)
    return { Motion: { motion_text: e2.Motion.motionText } };
  if ("SetDefaultFollowees" in e2)
    return { SetDefaultFollowees: { default_followees: e2.SetDefaultFollowees.defaultFollowees.map((n2) => [n2.topic, jr(n2.followees)]) } };
  if ("RegisterKnownNeuron" in e2) {
    let t3 = e2.RegisterKnownNeuron;
    return { RegisterKnownNeuron: { id: [{ id: t3.id }], known_neuron_data: [{ name: t3.name, description: t3.description !== void 0 ? [t3.description] : [] }] } };
  }
  if ("SetSnsTokenSwapOpenTimeWindow" in e2) {
    let { request: t3, swapCanisterId: n2 } = e2.SetSnsTokenSwapOpenTimeWindow;
    return { SetSnsTokenSwapOpenTimeWindow: { request: t3 === void 0 ? [] : [{ open_time_window: t3.openTimeWindow === void 0 ? [] : [{ start_timestamp_seconds: t3.openTimeWindow.startTimestampSeconds, end_timestamp_seconds: t3.openTimeWindow.endTimestampSeconds }] }], swap_canister_id: n2 === void 0 ? [] : [Principal.fromText(n2)] } };
  }
  if ("OpenSnsTokenSwap" in e2) {
    let { communityFundInvestmentE8s: t3, targetSwapCanisterId: n2, params: o5 } = e2.OpenSnsTokenSwap;
    return { OpenSnsTokenSwap: { community_fund_investment_e8s: we(t3), target_swap_canister_id: we(n2), params: o5 === void 0 ? [] : [{ min_participant_icp_e8s: o5.minParticipantIcpE8s, max_icp_e8s: o5.maxIcpE8s, swap_due_timestamp_seconds: o5.swapDueTimestampSeconds, min_participants: o5.minParticipants, sns_token_e8s: o5.snsTokenE8s, max_participant_icp_e8s: o5.maxParticipantIcpE8s, min_icp_e8s: o5.minIcpE8s, sale_delay_seconds: we(o5.saleDelaySeconds), neuron_basket_construction_parameters: we(o5.neuronBasketConstructionParameters) }] } };
  }
  if ("CreateServiceNervousSystem" in e2)
    return { CreateServiceNervousSystem: ta(e2.CreateServiceNervousSystem) };
  throw new v2(e2);
};
var na = (e2) => {
  if ("Split" in e2)
    return { Split: { amount_e8s: e2.Split.amount } };
  if ("Follow" in e2) {
    let t3 = e2.Follow;
    return { Follow: { topic: t3.topic, followees: t3.followees.map(gn) } };
  }
  if ("ClaimOrRefresh" in e2) {
    let t3 = e2.ClaimOrRefresh;
    return { ClaimOrRefresh: { by: t3.by ? [aa(t3.by)] : [] } };
  }
  if ("Configure" in e2) {
    let t3 = e2.Configure;
    return { Configure: { operation: t3.operation ? [oa(t3.operation)] : [] } };
  }
  if ("RegisterVote" in e2) {
    let t3 = e2.RegisterVote;
    return { RegisterVote: { vote: t3.vote, proposal: t3.proposal ? [io(t3.proposal)] : [] } };
  }
  if ("DisburseToNeuron" in e2) {
    let t3 = e2.DisburseToNeuron;
    return { DisburseToNeuron: { dissolve_delay_seconds: t3.dissolveDelaySeconds, kyc_verified: t3.kycVerified, amount_e8s: t3.amount, new_controller: t3.newController ? [Principal.fromText(t3.newController)] : [], nonce: t3.nonce } };
  }
  if ("MergeMaturity" in e2)
    return { MergeMaturity: { percentage_to_merge: e2.MergeMaturity.percentageToMerge } };
  if ("StakeMaturity" in e2) {
    let { percentageToStake: t3 } = e2.StakeMaturity;
    return { StakeMaturity: { percentage_to_stake: we(t3) } };
  }
  if ("MakeProposal" in e2) {
    let t3 = e2.MakeProposal;
    return { MakeProposal: { url: t3.url, title: [], action: t3.action ? [co(t3.action)] : [], summary: t3.summary } };
  }
  if ("Disburse" in e2) {
    let t3 = e2.Disburse;
    return { Disburse: { to_account: t3.toAccountId ? [Rn(t3.toAccountId)] : [], amount: t3.amount ? [uo(t3.amount)] : [] } };
  }
  if ("Spawn" in e2) {
    let t3 = e2.Spawn;
    return { Spawn: { percentage_to_spawn: t3.percentageToSpawn === void 0 ? [] : [t3.percentageToSpawn], new_controller: t3.newController ? [Principal.fromText(t3.newController)] : [], nonce: [] } };
  }
  if ("Merge" in e2) {
    let t3 = e2.Merge;
    return { Merge: { source_neuron_id: t3.sourceNeuronId ? [{ id: t3.sourceNeuronId }] : [] } };
  }
  throw new v2(e2);
};
var oa = (e2) => {
  if ("RemoveHotKey" in e2) {
    let t3 = e2.RemoveHotKey;
    return { RemoveHotKey: { hot_key_to_remove: t3.hotKeyToRemove != null ? [Principal.fromText(t3.hotKeyToRemove)] : [] } };
  }
  if ("AddHotKey" in e2) {
    let t3 = e2.AddHotKey;
    return { AddHotKey: { new_hot_key: t3.newHotKey ? [Principal.fromText(t3.newHotKey)] : [] } };
  }
  if ("StopDissolving" in e2)
    return { StopDissolving: {} };
  if ("StartDissolving" in e2)
    return { StartDissolving: {} };
  if ("IncreaseDissolveDelay" in e2)
    return { IncreaseDissolveDelay: { additional_dissolve_delay_seconds: e2.IncreaseDissolveDelay.additionalDissolveDelaySeconds } };
  if ("JoinCommunityFund" in e2 || "LeaveCommunityFund" in e2)
    return e2;
  if ("SetDissolveTimestamp" in e2)
    return { SetDissolveTimestamp: { dissolve_timestamp_seconds: e2.SetDissolveTimestamp.dissolveTimestampSeconds } };
  if ("ChangeAutoStakeMaturity" in e2) {
    let { requestedSettingForAutoStakeMaturity: t3 } = e2.ChangeAutoStakeMaturity;
    return { ChangeAutoStakeMaturity: { requested_setting_for_auto_stake_maturity: t3 } };
  }
  throw new v2(e2);
};
var ra = (e2) => {
  if ("ToRemove" in e2)
    return { ToRemove: Ke(e2.ToRemove) };
  if ("ToAdd" in e2)
    return { ToAdd: Ke(e2.ToAdd) };
  throw new v2(e2);
};
var Ke = (e2) => ({ id: e2.id != null ? [Principal.fromText(e2.id)] : [], reward_account: e2.rewardAccount != null ? [Rn(e2.rewardAccount)] : [] });
var uo = (e2) => ({ e8s: e2 });
var Rn = (e2) => ({ hash: to(e2) });
var ao = (e2) => {
  if ("RewardToNeuron" in e2)
    return { RewardToNeuron: { dissolve_delay_seconds: e2.RewardToNeuron.dissolveDelaySeconds } };
  if ("RewardToAccount" in e2)
    return { RewardToAccount: { to_account: e2.RewardToAccount.toAccount != null ? [Rn(e2.RewardToAccount.toAccount)] : [] } };
  throw new v2(e2);
};
var aa = (e2) => {
  if ("NeuronIdOrSubaccount" in e2)
    return { NeuronIdOrSubaccount: {} };
  if ("Memo" in e2)
    return { Memo: e2.Memo };
  if ("MemoAndController" in e2)
    return { MemoAndController: { memo: e2.MemoAndController.memo, controller: e2.MemoAndController.controller ? [e2.MemoAndController.controller] : [] } };
  throw new v2(e2);
};
var po = (e2) => ({ neuron_ids: BigUint64Array.from(e2 ?? []), include_neurons_readable_by_caller: !e2 });
var ia = ({ id: e2, command: t3, neuronIdOrSubaccount: n2 }) => ({ id: e2 ? [gn(e2)] : [], command: t3 ? [na(t3)] : [], neuron_id_or_subaccount: n2 ? [zr(n2)] : [] });
var lo = ({ includeRewardStatus: e2, beforeProposal: t3, excludeTopic: n2, includeStatus: o5, limit: r, includeAllManageNeuronProposals: a }) => ({ include_reward_status: Int32Array.from(e2), before_proposal: t3 ? [io(t3)] : [], limit: r, exclude_topic: Int32Array.from(n2), include_all_manage_neuron_proposals: a !== void 0 ? [a] : [], include_status: Int32Array.from(o5) });
var _o = (e2) => ({ id: [], command: [{ ClaimOrRefresh: { by: [{ NeuronIdOrSubaccount: {} }] } }], neuron_id_or_subaccount: [{ NeuronId: { id: e2.neuronId } }] });
var mo = ({ memo: e2, controller: t3 }) => {
  let n2 = { ClaimOrRefresh: { by: [{ MemoAndController: { controller: t3 == null ? [] : [t3], memo: e2 } }] } };
  return { id: [], command: [n2], neuron_id_or_subaccount: [] };
};
var fo = ({ neuronId: e2, amount: t3 }) => ({ id: [], command: [{ Split: { amount_e8s: t3 } }], neuron_id_or_subaccount: [{ NeuronId: { id: e2 } }] });
var wo = ({ neuronId: e2, vote: t3, proposalId: n2 }) => $3({ neuronId: e2, command: { RegisterVote: { vote: t3, proposal: [{ id: n2 }] } } });
var No = (e2) => {
  let t3 = { MakeProposal: { url: e2.url, title: e2.title != null ? [e2.title] : [], summary: e2.summary, action: [co(e2.action)] } };
  return { id: [], command: [t3], neuron_id_or_subaccount: [{ NeuronId: { id: e2.neuronId } }] };
};
var yo = ({ neuronId: e2, topic: t3, followees: n2 }) => $3({ neuronId: e2, command: { Follow: { topic: t3, followees: n2.map((o5) => ({ id: o5 })) } } });
var go = ({ neuronId: e2, toAccountIdentifier: t3, amount: n2 }) => $3({ neuronId: e2, command: { Disburse: { to_account: t3 !== void 0 ? [t3.toAccountIdentifierHash()] : [], amount: n2 !== void 0 ? [uo(n2)] : [] } } });
var Ro = ({ neuronId: e2, percentageToMerge: t3 }) => $3({ neuronId: e2, command: { MergeMaturity: { percentage_to_merge: t3 } } });
var vo = ({ neuronId: e2, percentageToStake: t3 }) => $3({ neuronId: e2, command: { StakeMaturity: { percentage_to_stake: we(t3) } } });
var ho = ({ neuronId: e2, percentageToSpawn: t3, newController: n2, nonce: o5 }) => $3({ neuronId: e2, command: { Spawn: { percentage_to_spawn: t3 === void 0 ? [] : [t3], new_controller: n2 === void 0 ? [] : [n2], nonce: o5 === void 0 ? [] : [o5] } } });
var Oo = ({ neuronId: e2, principal: t3 }) => J({ neuronId: e2, operation: { AddHotKey: { new_hot_key: [t3] } } });
var So = ({ neuronId: e2, principal: t3 }) => J({ neuronId: e2, operation: { RemoveHotKey: { hot_key_to_remove: [t3] } } });
var bo = ({ neuronId: e2, additionalDissolveDelaySeconds: t3 }) => J({ neuronId: e2, operation: { IncreaseDissolveDelay: { additional_dissolve_delay_seconds: t3 } } });
var xo = ({ neuronId: e2, dissolveDelaySeconds: t3 }) => J({ neuronId: e2, operation: { SetDissolveTimestamp: { dissolve_timestamp_seconds: BigInt(t3) } } });
var ko = (e2) => J({ neuronId: e2, operation: { JoinCommunityFund: {} } });
var To = ({ neuronId: e2, autoStake: t3 }) => J({ neuronId: e2, operation: { ChangeAutoStakeMaturity: { requested_setting_for_auto_stake_maturity: t3 } } });
var Co = (e2) => J({ neuronId: e2, operation: { LeaveCommunityFund: {} } });
var vn = ({ sourceNeuronId: e2, targetNeuronId: t3 }) => $3({ neuronId: t3, command: { Merge: { source_neuron_id: [{ id: e2 }] } } });
var Po = (e2) => J({ neuronId: e2, operation: { StartDissolving: {} } });
var Mo = (e2) => J({ neuronId: e2, operation: { StopDissolving: {} } });
var $3 = ({ neuronId: e2, command: t3 }) => ({ id: [{ id: e2 }], command: [t3], neuron_id_or_subaccount: [] });
var J = ({ neuronId: e2, operation: t3 }) => $3({ neuronId: e2, command: { Configure: { operation: [t3] } } });
var Ao = async (e2) => {
  let { PrincipalId: t3, ManageNeuron: n2, NeuronId: o5 } = await p2(), r = new t3();
  r.setSerializedId(Principal.fromText(e2.principal).toUint8Array());
  let a = new n2.AddHotKey();
  a.setNewHotKey(r);
  let i2 = new n2.Configure();
  i2.setAddHotKey(a);
  let c3 = new n2();
  c3.setConfigure(i2);
  let d4 = new o5();
  return d4.setId(e2.neuronId.toString()), c3.setNeuronId(d4), c3;
};
var Vo = async (e2) => {
  let { PrincipalId: t3, ManageNeuron: n2, NeuronId: o5 } = await p2(), r = new t3();
  r.setSerializedId(Principal.fromText(e2.principal).toUint8Array());
  let a = new n2.RemoveHotKey();
  a.setHotKeyToRemove(r);
  let i2 = new n2.Configure();
  i2.setRemoveHotKey(a);
  let c3 = new n2();
  c3.setConfigure(i2);
  let d4 = new o5();
  return d4.setId(e2.neuronId.toString()), c3.setNeuronId(d4), c3;
};
var Eo = async ({ neuronId: e2, additionalDissolveDelaySeconds: t3 }) => {
  let { ManageNeuron: n2, NeuronId: o5 } = await p2(), r = new n2.IncreaseDissolveDelay();
  r.setAdditionalDissolveDelaySeconds(t3);
  let a = new n2.Configure();
  a.setIncreaseDissolveDelay(r);
  let i2 = new n2();
  i2.setConfigure(a);
  let c3 = new o5();
  return c3.setId(e2.toString()), i2.setNeuronId(c3), i2;
};
var Fo = async (e2) => {
  let { ManageNeuron: t3, NeuronId: n2 } = await p2(), o5 = new t3.Configure();
  o5.setStartDissolving(new t3.StartDissolving());
  let r = new t3();
  r.setConfigure(o5);
  let a = new n2();
  return a.setId(e2.toString()), r.setNeuronId(a), r;
};
var Bo = async (e2) => {
  let { ManageNeuron: t3, NeuronId: n2 } = await p2(), o5 = new t3.Configure();
  o5.setStopDissolving(new t3.StopDissolving());
  let r = new t3();
  r.setConfigure(o5);
  let a = new n2();
  return a.setId(e2.toString()), r.setNeuronId(a), r;
};
var qo = async (e2) => {
  let { ManageNeuron: t3, NeuronId: n2 } = await p2(), o5 = new t3.Configure();
  o5.setJoinCommunityFund(new t3.JoinCommunityFund());
  let r = new t3();
  r.setConfigure(o5);
  let a = new n2();
  return a.setId(e2.toString()), r.setNeuronId(a), r;
};
var Uo = async (e2) => {
  let { ManageNeuron: t3, NeuronId: n2, AccountIdentifier: o5 } = await p2(), r = new t3.Disburse();
  if (e2.toAccountId) {
    let c3 = new o5();
    c3.setHash(Uint8Array.from(Buffer.from(e2.toAccountId, "hex"))), r.setToAccount(c3);
  }
  if (e2.amount != null) {
    let c3 = new t3.Disburse.Amount();
    c3.setE8s(e2.amount.toString()), r.setAmount(c3);
  }
  let a = new t3();
  a.setDisburse(r);
  let i2 = new n2();
  return i2.setId(e2.neuronId.toString()), a.setNeuronId(i2), a;
};
var Ko = async (e2) => {
  let { ManageNeuron: t3, NeuronId: n2 } = await p2(), o5 = new t3.MergeMaturity();
  o5.setPercentageToMerge(e2.percentageToMerge);
  let r = new t3(), a = new n2();
  return a.setId(e2.neuronId.toString()), r.setNeuronId(a), r.setMergeMaturity(o5), r;
};
var Ho = async (e2) => {
  let { ManageNeuron: t3, NeuronId: n2, PrincipalId: o5 } = await p2(), r = new t3.Spawn();
  if (e2.newController) {
    let c3 = new o5();
    c3.setSerializedId(Principal.fromText(e2.newController).toUint8Array().slice(4)), r.setNewController(c3);
  }
  e2.percentageToSpawn !== void 0 && r.setPercentageToSpawn(e2.percentageToSpawn);
  let a = new t3();
  a.setSpawn(r);
  let i2 = new n2();
  return i2.setId(e2.neuronId.toString()), a.setNeuronId(i2), a;
};
var Wo = ((a) => (a[a.Unspecified = 0] = "Unspecified", a[a.Locked = 1] = "Locked", a[a.Dissolving = 2] = "Dissolving", a[a.Dissolved = 3] = "Dissolved", a[a.Spawning = 4] = "Spawning", a))(Wo || {});
var sa = ((l3) => (l3[l3.Unspecified = 0] = "Unspecified", l3[l3.ManageNeuron = 1] = "ManageNeuron", l3[l3.ExchangeRate = 2] = "ExchangeRate", l3[l3.NetworkEconomics = 3] = "NetworkEconomics", l3[l3.Governance = 4] = "Governance", l3[l3.NodeAdmin = 5] = "NodeAdmin", l3[l3.ParticipantManagement = 6] = "ParticipantManagement", l3[l3.SubnetManagement = 7] = "SubnetManagement", l3[l3.NetworkCanisterManagement = 8] = "NetworkCanisterManagement", l3[l3.Kyc = 9] = "Kyc", l3[l3.NodeProviderRewards = 10] = "NodeProviderRewards", l3[l3.SnsDecentralizationSale = 11] = "SnsDecentralizationSale", l3[l3.SubnetReplicaVersionManagement = 12] = "SubnetReplicaVersionManagement", l3[l3.ReplicaVersionManagement = 13] = "ReplicaVersionManagement", l3[l3.SnsAndCommunityFund = 14] = "SnsAndCommunityFund", l3))(sa || {});
var ca = ((a) => (a[a.Unknown = 0] = "Unknown", a[a.AcceptVotes = 1] = "AcceptVotes", a[a.ReadyToSettle = 2] = "ReadyToSettle", a[a.Settled = 3] = "Settled", a[a.Ineligible = 4] = "Ineligible", a))(ca || {});
var ua = ((i2) => (i2[i2.Unknown = 0] = "Unknown", i2[i2.Open = 1] = "Open", i2[i2.Rejected = 2] = "Rejected", i2[i2.Accepted = 3] = "Accepted", i2[i2.Executed = 4] = "Executed", i2[i2.Failed = 5] = "Failed", i2))(ua || {});
var da = ((o5) => (o5[o5.Unspecified = 0] = "Unspecified", o5[o5.Yes = 1] = "Yes", o5[o5.No = 2] = "No", o5))(da || {});
var pa = ((u3) => (u3[u3.Unspecified = 0] = "Unspecified", u3[u3.CreateSubnet = 1] = "CreateSubnet", u3[u3.AddNodeToSubnet = 2] = "AddNodeToSubnet", u3[u3.NnsCanisterInstall = 3] = "NnsCanisterInstall", u3[u3.NnsCanisterUpgrade = 4] = "NnsCanisterUpgrade", u3[u3.BlessReplicaVersion = 5] = "BlessReplicaVersion", u3[u3.RecoverSubnet = 6] = "RecoverSubnet", u3[u3.UpdateConfigOfSubnet = 7] = "UpdateConfigOfSubnet", u3[u3.AssignNoid = 8] = "AssignNoid", u3[u3.NnsRootUpgrade = 9] = "NnsRootUpgrade", u3[u3.IcpXdrConversionRate = 10] = "IcpXdrConversionRate", u3[u3.UpdateSubnetReplicaVersion = 11] = "UpdateSubnetReplicaVersion", u3[u3.ClearProvisionalWhitelist = 12] = "ClearProvisionalWhitelist", u3[u3.RemoveNodesFromSubnet = 13] = "RemoveNodesFromSubnet", u3[u3.SetAuthorizedSubnetworks = 14] = "SetAuthorizedSubnetworks", u3[u3.SetFirewallConfig = 15] = "SetFirewallConfig", u3[u3.UpdateNodeOperatorConfig = 16] = "UpdateNodeOperatorConfig", u3[u3.StopOrStartNnsCanister = 17] = "StopOrStartNnsCanister", u3[u3.RemoveNodes = 18] = "RemoveNodes", u3[u3.UninstallCode = 19] = "UninstallCode", u3[u3.UpdateNodeRewardsTable = 20] = "UpdateNodeRewardsTable", u3[u3.AddOrRemoveDataCenters = 21] = "AddOrRemoveDataCenters", u3[u3.UpdateUnassignedNodesConfig = 22] = "UpdateUnassignedNodesConfig", u3[u3.RemoveNodeOperators = 23] = "RemoveNodeOperators", u3[u3.RerouteCanisterRanges = 24] = "RerouteCanisterRanges", u3[u3.AddFirewallRules = 25] = "AddFirewallRules", u3[u3.RemoveFirewallRules = 26] = "RemoveFirewallRules", u3[u3.UpdateFirewallRules = 27] = "UpdateFirewallRules", u3[u3.PrepareCanisterMigration = 28] = "PrepareCanisterMigration", u3[u3.CompleteCanisterMigration = 29] = "CompleteCanisterMigration", u3[u3.AddSnsWasm = 30] = "AddSnsWasm", u3[u3.ChangeSubnetMembership = 31] = "ChangeSubnetMembership", u3[u3.UpdateSubnetType = 32] = "UpdateSubnetType", u3[u3.ChangeSubnetTypeAssignment = 33] = "ChangeSubnetTypeAssignment", u3[u3.UpdateSnsWasmSnsSubnetIds = 34] = "UpdateSnsWasmSnsSubnetIds", u3[u3.UpdateAllowedPrincipals = 35] = "UpdateAllowedPrincipals", u3[u3.RetireReplicaVersion = 36] = "RetireReplicaVersion", u3[u3.InsertSnsWasmUpgradePathEntries = 37] = "InsertSnsWasmUpgradePathEntries", u3[u3.UpdateElectedReplicaVersions = 38] = "UpdateElectedReplicaVersions", u3[u3.BitcoinSetConfig = 39] = "BitcoinSetConfig", u3))(pa || {});
var On = ({ neuronId: e2, neuronInfo: t3, rawNeuron: n2, canisterId: o5 }) => {
  let r = n2 ? fa({ neuron: n2, canisterId: o5 }) : void 0;
  return { neuronId: e2, dissolveDelaySeconds: t3.dissolve_delay_seconds, recentBallots: t3.recent_ballots.map(Jo), createdTimestampSeconds: t3.created_timestamp_seconds, state: t3.state, joinedCommunityFundTimestampSeconds: t3.joined_community_fund_timestamp_seconds.length ? t3.joined_community_fund_timestamp_seconds[0] : void 0, retrievedAtTimestampSeconds: t3.retrieved_at_timestamp_seconds, votingPower: t3.voting_power, ageSeconds: t3.age_seconds, fullNeuron: r };
};
var fa = ({ neuron: e2, canisterId: t3 }) => ({ id: e2.id.length ? X2(e2.id[0]) : void 0, stakedMaturityE8sEquivalent: K(e2.staked_maturity_e8s_equivalent), controller: e2.controller.length ? e2.controller[0].toString() : void 0, recentBallots: e2.recent_ballots.map(Jo), kycVerified: e2.kyc_verified, notForProfit: e2.not_for_profit, cachedNeuronStake: e2.cached_neuron_stake_e8s, createdTimestampSeconds: e2.created_timestamp_seconds, autoStakeMaturity: K(e2.auto_stake_maturity), maturityE8sEquivalent: e2.maturity_e8s_equivalent, agingSinceTimestampSeconds: e2.aging_since_timestamp_seconds, neuronFees: e2.neuron_fees_e8s, hotKeys: e2.hot_keys.map((n2) => n2.toString()), accountIdentifier: oo(t3, e2.account), joinedCommunityFundTimestampSeconds: e2.joined_community_fund_timestamp_seconds.length ? e2.joined_community_fund_timestamp_seconds[0] : void 0, dissolveState: e2.dissolve_state.length ? wa(e2.dissolve_state[0]) : void 0, spawnAtTimesSeconds: e2.spawn_at_timestamp_seconds[0], followees: e2.followees.map(([n2, o5]) => $o({ topic: n2, followees: o5 })) });
var Jo = ({ vote: e2, proposal_id: t3 }) => ({ vote: e2, proposalId: t3.length ? X2(t3[0]) : void 0 });
var wa = (e2) => "DissolveDelaySeconds" in e2 ? { DissolveDelaySeconds: e2.DissolveDelaySeconds } : { WhenDissolvedTimestampSeconds: e2.WhenDissolvedTimestampSeconds };
var $o = ({ topic: e2, followees: t3 }) => ({ topic: e2, followees: t3.followees.map(X2) });
var X2 = ({ id: e2 }) => e2;
var Na = (e2) => {
  if ("NeuronId" in e2)
    return { NeuronId: e2.NeuronId.id };
  if ("Subaccount" in e2)
    return { Subaccount: ce(e2.Subaccount) };
  throw new v2(e2);
};
var ya = ({ neuronId: e2, ballot: t3 }) => {
  let { vote: n2, voting_power: o5 } = t3;
  return { neuronId: e2, vote: n2, votingPower: o5 };
};
var ga = ({ title: e2, url: t3, action: n2, summary: o5 }) => ({ title: e2.length ? e2[0] : void 0, url: t3, action: n2.length ? Xo(n2[0]) : void 0, summary: o5 });
var Xo = (e2) => {
  var _a;
  if ("ExecuteNnsFunction" in e2)
    return { ExecuteNnsFunction: { nnsFunctionId: e2.ExecuteNnsFunction.nns_function } };
  if ("ManageNeuron" in e2) {
    let t3 = e2.ManageNeuron;
    return { ManageNeuron: { id: t3.id.length ? X2(t3.id[0]) : void 0, command: t3.command.length ? va(t3.command[0]) : void 0, neuronIdOrSubaccount: t3.neuron_id_or_subaccount.length ? Na(t3.neuron_id_or_subaccount[0]) : void 0 } };
  }
  if ("ApproveGenesisKyc" in e2)
    return { ApproveGenesisKyc: { principals: e2.ApproveGenesisKyc.principals.map((n2) => n2.toString()) } };
  if ("ManageNetworkEconomics" in e2) {
    let t3 = e2.ManageNetworkEconomics;
    return { ManageNetworkEconomics: { neuronMinimumStake: t3.neuron_minimum_stake_e8s, maxProposalsToKeepPerTopic: t3.max_proposals_to_keep_per_topic, neuronManagementFeePerProposal: t3.neuron_management_fee_per_proposal_e8s, rejectCost: t3.reject_cost_e8s, transactionFee: t3.transaction_fee_e8s, neuronSpawnDissolveDelaySeconds: t3.neuron_spawn_dissolve_delay_seconds, minimumIcpXdrRate: t3.minimum_icp_xdr_rate, maximumNodeProviderRewards: t3.maximum_node_provider_rewards_e8s } };
  }
  if ("RewardNodeProvider" in e2) {
    let t3 = e2.RewardNodeProvider;
    return { RewardNodeProvider: { nodeProvider: t3.node_provider.length ? He(t3.node_provider[0]) : void 0, amountE8s: t3.amount_e8s, rewardMode: t3.reward_mode.length ? Go(t3.reward_mode[0]) : void 0 } };
  }
  if ("RewardNodeProviders" in e2) {
    let t3 = e2.RewardNodeProviders;
    return { RewardNodeProviders: { useRegistryDerivedRewards: t3.use_registry_derived_rewards.length ? t3.use_registry_derived_rewards[0] : void 0, rewards: t3.rewards.map((n2) => ({ nodeProvider: n2.node_provider.length ? He(n2.node_provider[0]) : void 0, amountE8s: n2.amount_e8s, rewardMode: n2.reward_mode.length ? Go(n2.reward_mode[0]) : void 0 })) } };
  }
  if ("AddOrRemoveNodeProvider" in e2) {
    let t3 = e2.AddOrRemoveNodeProvider;
    return { AddOrRemoveNodeProvider: { change: t3.change.length ? Oa(t3.change[0]) : void 0 } };
  }
  if ("Motion" in e2)
    return { Motion: { motionText: e2.Motion.motion_text } };
  if ("SetDefaultFollowees" in e2)
    return { SetDefaultFollowees: { defaultFollowees: e2.SetDefaultFollowees.default_followees.map(([n2, o5]) => $o({ topic: n2, followees: o5 })) } };
  if ("RegisterKnownNeuron" in e2) {
    let t3 = e2.RegisterKnownNeuron;
    return { RegisterKnownNeuron: xa(t3) };
  }
  if ("SetSnsTokenSwapOpenTimeWindow" in e2) {
    let t3 = e2.SetSnsTokenSwapOpenTimeWindow, n2 = ((_a = t3.request) == null ? void 0 : _a.length) ? { openTimeWindow: t3.request[0].open_time_window.length ? { startTimestampSeconds: t3.request[0].open_time_window[0].start_timestamp_seconds, endTimestampSeconds: t3.request[0].open_time_window[0].end_timestamp_seconds } : void 0 } : void 0, o5 = (t3 == null ? void 0 : t3.swap_canister_id.length) ? t3.swap_canister_id[0].toString() : void 0;
    return { SetSnsTokenSwapOpenTimeWindow: { request: n2, swapCanisterId: o5 } };
  }
  if ("OpenSnsTokenSwap" in e2) {
    let t3 = e2.OpenSnsTokenSwap, n2 = K(t3.params);
    return { OpenSnsTokenSwap: { communityFundInvestmentE8s: K(t3.community_fund_investment_e8s), targetSwapCanisterId: K(t3.target_swap_canister_id), ...n2 !== void 0 && { params: { minParticipantIcpE8s: n2.min_participant_icp_e8s, maxIcpE8s: n2.max_icp_e8s, swapDueTimestampSeconds: n2.swap_due_timestamp_seconds, minParticipants: n2.min_participants, snsTokenE8s: n2.sns_token_e8s, maxParticipantIcpE8s: n2.max_participant_icp_e8s, minIcpE8s: n2.min_icp_e8s, saleDelaySeconds: K(n2.sale_delay_seconds), neuronBasketConstructionParameters: K(n2.neuron_basket_construction_parameters) } } } };
  }
  if ("CreateServiceNervousSystem" in e2) {
    let t3 = e2.CreateServiceNervousSystem;
    return { CreateServiceNervousSystem: { url: K(t3.url), governanceParameters: Ba(K(t3.governance_parameters)), fallbackControllerPrincipalIds: t3.fallback_controller_principal_ids.map((n2) => n2.toString()), logo: Do(K(t3.logo)), name: K(t3.name), ledgerParameters: Ea(K(t3.ledger_parameters)), description: K(t3.description), dappCanisters: t3.dapp_canisters.map(Va) ?? [], swapParameters: Ua(K(t3.swap_parameters)), initialTokenDistribution: Wa(K(t3.initial_token_distribution)) } };
  }
  throw new v2(e2);
};
var Ra = (e2) => ({ no: e2.no, yes: e2.yes, total: e2.total, timestampSeconds: e2.timestamp_seconds });
var va = (e2) => {
  if ("Spawn" in e2) {
    let t3 = e2.Spawn;
    return { Spawn: { newController: t3.new_controller.length ? t3.new_controller[0].toString() : void 0, percentageToSpawn: t3.percentage_to_spawn.length ? t3.percentage_to_spawn[0] : 0 } };
  }
  if ("Split" in e2)
    return { Split: { amount: e2.Split.amount_e8s } };
  if ("Follow" in e2) {
    let t3 = e2.Follow;
    return { Follow: { topic: t3.topic, followees: t3.followees.map(X2) } };
  }
  if ("ClaimOrRefresh" in e2) {
    let t3 = e2.ClaimOrRefresh;
    return { ClaimOrRefresh: { by: t3.by.length ? ba(t3.by[0]) : void 0 } };
  }
  if ("Configure" in e2) {
    let t3 = e2.Configure;
    return { Configure: { operation: t3.operation.length ? ha(t3.operation[0]) : void 0 } };
  }
  if ("RegisterVote" in e2) {
    let t3 = e2.RegisterVote;
    return { RegisterVote: { vote: t3.vote, proposal: t3.proposal.length ? X2(t3.proposal[0]) : void 0 } };
  }
  if ("DisburseToNeuron" in e2) {
    let t3 = e2.DisburseToNeuron;
    return { DisburseToNeuron: { dissolveDelaySeconds: t3.dissolve_delay_seconds, kycVerified: t3.kyc_verified, amount: t3.amount_e8s, newController: t3.new_controller.length ? t3.new_controller[0].toString() : void 0, nonce: t3.nonce } };
  }
  if ("MergeMaturity" in e2)
    return { MergeMaturity: { percentageToMerge: e2.MergeMaturity.percentage_to_merge } };
  if ("StakeMaturity" in e2) {
    let { percentage_to_stake: t3 } = e2.StakeMaturity;
    return { StakeMaturity: { percentageToStake: K(t3) } };
  }
  if ("MakeProposal" in e2) {
    let t3 = e2.MakeProposal;
    return { MakeProposal: { title: t3.title.length ? t3.title[0] : void 0, url: t3.url, action: t3.action.length ? Xo(t3.action[0]) : void 0, summary: t3.summary } };
  }
  if ("Disburse" in e2) {
    let t3 = e2.Disburse;
    return { Disburse: { toAccountId: t3.to_account.length ? Sn(t3.to_account[0]) : void 0, amount: t3.amount.length ? Sa(t3.amount[0]) : void 0 } };
  }
  if ("Merge" in e2) {
    let t3 = e2.Merge;
    return { Merge: { sourceNeuronId: t3.source_neuron_id.length ? t3.source_neuron_id[0].id : void 0 } };
  }
  throw new v2(e2);
};
var ha = (e2) => {
  if ("RemoveHotKey" in e2) {
    let t3 = e2.RemoveHotKey;
    return { RemoveHotKey: { hotKeyToRemove: t3.hot_key_to_remove.length ? t3.hot_key_to_remove[0].toString() : void 0 } };
  }
  if ("AddHotKey" in e2) {
    let t3 = e2.AddHotKey;
    return { AddHotKey: { newHotKey: t3.new_hot_key.length ? t3.new_hot_key[0].toString() : void 0 } };
  }
  if ("StopDissolving" in e2)
    return { StopDissolving: {} };
  if ("StartDissolving" in e2)
    return { StartDissolving: {} };
  if ("IncreaseDissolveDelay" in e2)
    return { IncreaseDissolveDelay: { additionalDissolveDelaySeconds: e2.IncreaseDissolveDelay.additional_dissolve_delay_seconds } };
  if ("JoinCommunityFund" in e2 || "LeaveCommunityFund" in e2)
    return e2;
  if ("SetDissolveTimestamp" in e2)
    return { SetDissolveTimestamp: { dissolveTimestampSeconds: e2.SetDissolveTimestamp.dissolve_timestamp_seconds } };
  if ("ChangeAutoStakeMaturity" in e2) {
    let { requested_setting_for_auto_stake_maturity: t3 } = e2.ChangeAutoStakeMaturity;
    return { ChangeAutoStakeMaturity: { requestedSettingForAutoStakeMaturity: t3 } };
  }
  throw new v2(e2);
};
var Oa = (e2) => {
  if ("ToRemove" in e2)
    return { ToRemove: He(e2.ToRemove) };
  if ("ToAdd" in e2)
    return { ToAdd: He(e2.ToAdd) };
  throw new v2(e2);
};
var He = (e2) => ({ id: e2.id.length ? e2.id[0].toString() : void 0, rewardAccount: e2.reward_account.length ? Sn(e2.reward_account[0]) : void 0 });
var Sa = (e2) => e2.e8s;
var Sn = (e2) => no(new Uint8Array(e2.hash));
var Go = (e2) => {
  if ("RewardToNeuron" in e2)
    return { RewardToNeuron: { dissolveDelaySeconds: e2.RewardToNeuron.dissolve_delay_seconds } };
  if ("RewardToAccount" in e2)
    return { RewardToAccount: { toAccount: e2.RewardToAccount.to_account != null && e2.RewardToAccount.to_account.length ? Sn(e2.RewardToAccount.to_account[0]) : void 0 } };
  throw new v2(e2);
};
var ba = (e2) => {
  if ("NeuronIdOrSubaccount" in e2)
    return { NeuronIdOrSubaccount: {} };
  if ("Memo" in e2)
    return { Memo: e2.Memo };
  if ("MemoAndController" in e2)
    return { MemoAndController: { memo: e2.MemoAndController.memo, controller: e2.MemoAndController.controller.length ? e2.MemoAndController.controller[0] : void 0 } };
  throw new v2(e2);
};
var bn = (e2) => ({ id: e2.id.length ? X2(e2.id[0]) : void 0, ballots: e2.ballots.map((t3) => ya({ neuronId: t3[0], ballot: t3[1] })), rejectCost: e2.reject_cost_e8s, proposalTimestampSeconds: e2.proposal_timestamp_seconds, rewardEventRound: e2.reward_event_round, failedTimestampSeconds: e2.failed_timestamp_seconds, deadlineTimestampSeconds: K(e2.deadline_timestamp_seconds), decidedTimestampSeconds: e2.decided_timestamp_seconds, proposal: e2.proposal.length ? ga(e2.proposal[0]) : void 0, proposer: e2.proposer.length ? X2(e2.proposer[0]) : void 0, latestTally: e2.latest_tally.length ? Ra(e2.latest_tally[0]) : void 0, executedTimestampSeconds: e2.executed_timestamp_seconds, topic: e2.topic, status: e2.status, rewardStatus: e2.reward_status });
var Yo = ({ response: { neuron_infos: e2, full_neurons: t3 }, canisterId: n2 }) => e2.map(([o5, r]) => On({ neuronId: o5, neuronInfo: r, rawNeuron: t3.find((a) => a.id.length && a.id[0].id === o5), canisterId: n2 }));
var Qo = ({ proposal_info: e2 }) => ({ proposals: e2.map(bn) });
var xa = ({ id: e2, known_neuron_data: t3 }) => {
  var _a, _b, _c;
  return { id: ((_a = e2[0]) == null ? void 0 : _a.id) ?? BigInt(0), name: ((_b = t3[0]) == null ? void 0 : _b.name) ?? "", description: ((_c = t3[0]) == null ? void 0 : _c.description[0]) ?? "" };
};
var Zo = (e2) => {
  let t3 = e2.getProposalId();
  return { vote: e2.getVote(), proposalId: t3 !== void 0 ? BigInt(t3.getId()) : void 0 };
};
var ka = (e2) => (e2 == null ? void 0 : e2.hasWhenDissolvedTimestampSeconds()) ? 2 : (e2 == null ? void 0 : e2.hasDissolveDelaySeconds()) ? e2.getDissolveDelaySeconds() === "0" ? 3 : 1 : 0;
var Ta = (e2) => e2.toArray().map(([t3, n2]) => {
  var _a;
  return { topic: Number(t3), followees: ((_a = n2.getFolloweesList) == null ? void 0 : _a.call(n2).map((o5) => BigInt(o5.getId()))) ?? [] };
});
var jo = (e2) => Principal.fromUint8Array(e2.getSerializedId_asU8()).toText();
var Ca = ({ neuron: e2, canisterId: t3 }) => {
  let n2 = E2.fromBytes(e2.getAccount_asU8());
  return w.fromPrincipal({ principal: t3, subAccount: n2 });
};
var Pa = ({ pbNeuron: e2, pbNeuronInfo: t3, canisterId: n2 }) => {
  let o5 = e2.getId(), r = e2.getController(), a = r === void 0 ? r : jo(r), i2;
  return e2.hasWhenDissolvedTimestampSeconds() ? i2 = { WhenDissolvedTimestampSeconds: BigInt(e2.getWhenDissolvedTimestampSeconds()) } : e2.hasDissolveDelaySeconds() && (i2 = { DissolveDelaySeconds: BigInt(e2.getDissolveDelaySeconds()) }), { id: o5 === void 0 ? void 0 : BigInt(o5.getId()), stakedMaturityE8sEquivalent: void 0, controller: a, recentBallots: t3.getRecentBallotsList().map(Zo), kycVerified: e2.getKycVerified(), notForProfit: e2.getNotForProfit(), cachedNeuronStake: BigInt(e2.getCachedNeuronStakeE8s()), createdTimestampSeconds: BigInt(e2.getCreatedTimestampSeconds()), autoStakeMaturity: void 0, maturityE8sEquivalent: BigInt(e2.getMaturityE8sEquivalent()), agingSinceTimestampSeconds: BigInt(e2.getAgingSinceTimestampSeconds()), spawnAtTimesSeconds: e2.hasSpawnAtTimestampSeconds() ? BigInt(e2.getSpawnAtTimestampSeconds()) : void 0, neuronFees: BigInt(e2.getNeuronFeesE8s()), hotKeys: e2.getHotKeysList().map(jo), accountIdentifier: Ca({ neuron: e2, canisterId: n2 }).toHex(), joinedCommunityFundTimestampSeconds: void 0, dissolveState: i2, followees: Ta(e2.getFolloweesMap()) };
};
var Io = ({ pbNeurons: e2, canisterId: t3 }) => (n2) => {
  let o5 = e2.find((a) => {
    var _a;
    return ((_a = a.getId()) == null ? void 0 : _a.getId()) === n2.getKey();
  }), r = n2.getValue();
  if (r === void 0)
    throw new Error(`NeuronInfo not present for neuron ${n2.getKey()}`);
  return { neuronId: BigInt(n2.getKey()), dissolveDelaySeconds: BigInt(r.getDissolveDelaySeconds()), recentBallots: r.getRecentBallotsList().map(Zo), createdTimestampSeconds: BigInt(r.getCreatedTimestampSeconds()), state: ka(o5), joinedCommunityFundTimestampSeconds: void 0, retrievedAtTimestampSeconds: BigInt(r.getRetrievedAtTimestampSeconds()), votingPower: BigInt(r.getVotingPower()), ageSeconds: BigInt(r.getAgeSeconds()), fullNeuron: o5 === void 0 ? void 0 : Pa({ pbNeuron: o5, pbNeuronInfo: r, canisterId: t3 }) };
};
var We = (e2) => e2 === void 0 ? void 0 : { basisPoints: K(e2.basis_points) };
var q2 = (e2) => e2 === void 0 ? void 0 : { seconds: K(e2.seconds) };
var Ma = (e2) => e2 === void 0 ? void 0 : { secondsAfterUtcMidnight: K(e2.seconds_after_utc_midnight) };
var Aa = (e2) => e2 === void 0 ? void 0 : { isoCodes: e2.iso_codes };
var U2 = (e2) => e2 === void 0 ? void 0 : { e8s: K(e2.e8s) };
var Va = (e2) => e2 === void 0 || e2.id.length === 0 ? void 0 : Be(e2.id).toString();
var Do = (e2) => e2 === void 0 ? void 0 : { base64Encoding: K(e2.base64_encoding) };
var Ea = (e2) => e2 === void 0 ? void 0 : { transactionFee: U2(K(e2.transaction_fee)), tokenSymbol: K(e2.token_symbol), tokenLogo: Do(K(e2.token_logo)), tokenName: K(e2.token_name) };
var Fa = (e2) => e2 === void 0 ? void 0 : { rewardRateTransitionDuration: q2(K(e2.reward_rate_transition_duration)), initialRewardRate: We(K(e2.initial_reward_rate)), finalRewardRate: We(K(e2.final_reward_rate)) };
var Ba = (e2) => e2 === void 0 ? void 0 : { neuronMaximumDissolveDelayBonus: We(K(e2.neuron_maximum_dissolve_delay_bonus)), neuronMaximumAgeForAgeBonus: q2(K(e2.neuron_maximum_age_for_age_bonus)), neuronMaximumDissolveDelay: q2(K(e2.neuron_maximum_dissolve_delay)), neuronMinimumDissolveDelayToVote: q2(K(e2.neuron_minimum_dissolve_delay_to_vote)), neuronMaximumAgeBonus: We(K(e2.neuron_maximum_age_bonus)), neuronMinimumStake: U2(K(e2.neuron_minimum_stake)), proposalWaitForQuietDeadlineIncrease: q2(K(e2.proposal_wait_for_quiet_deadline_increase)), proposalInitialVotingPeriod: q2(K(e2.proposal_initial_voting_period)), proposalRejectionFee: U2(K(e2.proposal_rejection_fee)), votingRewardParameters: Fa(K(e2.voting_reward_parameters)) };
var qa = (e2) => e2 === void 0 ? void 0 : { dissolveDelayInterval: q2(K(e2.dissolve_delay_interval)), count: K(e2.count) };
var Ua = (e2) => e2 === void 0 ? void 0 : { minimumParticipants: K(e2.minimum_participants), duration: q2(K(e2.duration)), neuronBasketConstructionParameters: qa(K(e2.neuron_basket_construction_parameters)), confirmationText: K(e2.confirmation_text), maximumParticipantIcp: U2(K(e2.maximum_participant_icp)), neuronsFundInvestmentIcp: U2(K(e2.neurons_fund_investment_icp)), minimumIcp: U2(K(e2.minimum_icp)), minimumParticipantIcp: U2(K(e2.minimum_participant_icp)), startTime: Ma(K(e2.start_time)), maximumIcp: U2(K(e2.maximum_icp)), restrictedCountries: Aa(K(e2.restricted_countries)) };
var zo = (e2) => e2 === void 0 ? void 0 : { total: U2(K(e2.total)) };
var Ka = (e2) => e2 === void 0 ? void 0 : { controller: e2.controller.length === 0 ? void 0 : e2.controller[0].toString(), dissolveDelay: q2(K(e2.dissolve_delay)), memo: K(e2.memo), vestingPeriod: q2(K(e2.vesting_period)), stake: U2(K(e2.stake)) };
var Ha = (e2) => e2 === void 0 ? void 0 : { developerNeurons: e2.developer_neurons.map(Ka) };
var Wa = (e2) => e2 === void 0 ? void 0 : { treasuryDistribution: zo(K(e2.treasury_distribution)), developerDistribution: Ha(K(e2.developer_distribution)), swapDistribution: zo(K(e2.swap_distribution)) };
var Lo = async (e2) => {
  let { ManageNeuronResponse: t3 } = await p2(), o5 = t3.deserializeBinary(e2).getError();
  if (o5)
    throw new P3({ error_message: o5.getErrorMessage(), error_type: o5.getErrorType() });
};
var xe2 = (e2) => {
  let { command: t3 } = e2, n2 = t3[0];
  if (!n2)
    throw new P3({ error_message: "Error updating neuron", error_type: 0 });
  if ("Error" in n2)
    throw new P3(n2.Error);
  return n2;
};
var h4 = async ({ request: e2, service: t3 }) => {
  let n2 = await t3.manage_neuron(e2);
  xe2(n2);
};
var er = async ({ request: e2, service: t3 }) => {
  let n2 = await t3.simulate_manage_neuron(e2);
  return xe2(n2);
};
var xn = (e2) => {
  if (e2.length != 64)
    throw new be(`Invalid account identifier ${e2}. The account identifier must be 64 chars in length.`);
  let t3 = Buffer.from(e2, "hex"), n2 = t3.slice(0, 4), o5 = Buffer.from(ye(t3.slice(4)));
  if (!o5.equals(n2))
    throw new be(`Account identifier ${e2} has an invalid checksum. Are you sure the account identifier is correct?

Expected checksum: ${o5.toString("hex")}
Found checksum: ${n2.toString("hex")}`);
};
var Ge = class {
  constructor(t3, n2, o5, r, a = false) {
    __publicField(this, "listNeurons", async ({ certified: t3 = true, neuronIds: n2 }) => {
      if (this.hardwareWallet && !t3)
        throw new qe();
      if (this.hardwareWallet)
        return this.listNeuronsHardwareWallet();
      let o5 = po(n2), r = await this.getGovernanceService(t3).list_neurons(o5);
      return Yo({ response: r, canisterId: this.canisterId });
    });
    __publicField(this, "listKnownNeurons", async (t3 = true) => (await this.getGovernanceService(t3).list_known_neurons()).known_neurons.map((o5) => {
      var _a, _b, _c;
      return { id: ((_a = K(o5.id)) == null ? void 0 : _a.id) ?? BigInt(0), name: ((_b = K(o5.known_neuron_data)) == null ? void 0 : _b.name) ?? "", description: K(((_c = K(o5.known_neuron_data)) == null ? void 0 : _c.description) ?? []) };
    }));
    __publicField(this, "getLastestRewardEvent", async (t3 = true) => this.getGovernanceService(t3).get_latest_reward_event());
    __publicField(this, "listProposals", async ({ request: t3, certified: n2 = true }) => {
      let o5 = lo(t3), r = await this.getGovernanceService(n2).list_proposals(o5);
      return Qo(r);
    });
    __publicField(this, "stakeNeuron", async ({ stake: t3, principal: n2, fromSubAccount: o5, ledgerCanister: r, createdAt: a, fee: i2 }) => {
      if (t3 < o3)
        throw new Be2(t3);
      let c3 = new Uint8Array((0, nr.default)(8)), d4 = ne(c3), m4 = this.buildNeuronStakeSubAccount(c3, n2), f2 = w.fromPrincipal({ principal: this.canisterId, subAccount: m4 });
      await r.transfer({ memo: d4, amount: t3, fromSubAccount: o5, to: f2, createdAt: a, fee: i2 });
      let _4 = await this.claimOrRefreshNeuronFromAccount({ controller: n2, memo: d4 });
      if (Y(_4))
        throw new Fe();
      return _4;
    });
    __publicField(this, "increaseDissolveDelay", async ({ neuronId: t3, additionalDissolveDelaySeconds: n2 }) => {
      if (this.hardwareWallet)
        return this.increaseDissolveDelayHardwareWallet({ neuronId: t3, additionalDissolveDelaySeconds: n2 });
      let o5 = bo({ neuronId: t3, additionalDissolveDelaySeconds: n2 });
      return h4({ request: o5, service: this.certifiedService });
    });
    __publicField(this, "setDissolveDelay", async ({ neuronId: t3, dissolveDelaySeconds: n2 }) => {
      let o5 = xo({ neuronId: t3, dissolveDelaySeconds: n2 });
      return h4({ request: o5, service: this.certifiedService });
    });
    __publicField(this, "startDissolving", async (t3) => {
      if (this.hardwareWallet)
        return this.startDissolvingHardwareWallet(t3);
      let n2 = Po(t3);
      return h4({ request: n2, service: this.certifiedService });
    });
    __publicField(this, "stopDissolving", async (t3) => {
      if (this.hardwareWallet)
        return this.stopDissolvingHardwareWallet(t3);
      let n2 = Mo(t3);
      return h4({ request: n2, service: this.certifiedService });
    });
    __publicField(this, "joinCommunityFund", async (t3) => {
      if (this.hardwareWallet)
        return this.joinCommunityFundHardwareWallet(t3);
      let n2 = ko(t3);
      return h4({ request: n2, service: this.certifiedService });
    });
    __publicField(this, "autoStakeMaturity", (t3) => h4({ request: To(t3), service: this.certifiedService }));
    __publicField(this, "leaveCommunityFund", async (t3) => {
      let n2 = Co(t3);
      return h4({ request: n2, service: this.certifiedService });
    });
    __publicField(this, "setNodeProviderAccount", async (t3) => {
      xn(t3);
      let n2 = w.fromHex(t3), o5 = await this.certifiedService.update_node_provider({ reward_account: [n2.toAccountIdentifierHash()] });
      if ("Err" in o5)
        throw new P3(o5.Err);
    });
    __publicField(this, "mergeNeurons", async (t3) => {
      let n2 = vn(t3);
      return h4({ request: n2, service: this.certifiedService });
    });
    __publicField(this, "simulateMergeNeurons", async (t3) => {
      var _a;
      let n2 = vn(t3), o5 = await er({ request: n2, service: this.certifiedService }), r, a, i2, c3;
      if ("Merge" in o5 && c(r = o5.Merge) && c(a = K(r.target_neuron_info)) && c(i2 = K(r.target_neuron)) && c(c3 = (_a = K(i2.id)) == null ? void 0 : _a.id))
        return On({ neuronId: c3, neuronInfo: a, rawNeuron: i2, canisterId: this.canisterId });
      throw new z(`simulateMergeNeurons: Unrecognized Merge error in ${JSON.stringify(o5)}`);
    });
    __publicField(this, "splitNeuron", async ({ neuronId: t3, amount: n2 }) => {
      let o5 = fo({ neuronId: t3, amount: n2 }), r = await this.certifiedService.manage_neuron(o5), a = xe2(r);
      if ("Split" in a) {
        let i2 = K(a.Split.created_neuron_id);
        if (Y(i2))
          throw new P3({ error_message: "Unexpected error splitting neuron. No neuronId in Split response.", error_type: 0 });
        return i2.id;
      }
      throw new z(`Unrecognized Split error in ${JSON.stringify(r)}`);
    });
    __publicField(this, "getProposal", async ({ proposalId: t3, certified: n2 = true }) => {
      let [o5] = await this.getGovernanceService(n2).get_proposal_info(t3);
      return o5 ? bn(o5) : void 0;
    });
    __publicField(this, "makeProposal", async (t3) => {
      let n2 = No(t3);
      return h4({ request: n2, service: this.certifiedService });
    });
    __publicField(this, "registerVote", async ({ neuronId: t3, vote: n2, proposalId: o5 }) => {
      let r = wo({ neuronId: t3, vote: n2, proposalId: o5 });
      return h4({ request: r, service: this.certifiedService });
    });
    __publicField(this, "setFollowees", async (t3) => {
      let n2 = yo(t3);
      return h4({ request: n2, service: this.certifiedService });
    });
    __publicField(this, "disburse", async ({ neuronId: t3, toAccountId: n2, amount: o5 }) => {
      if (c(n2) && xn(n2), this.hardwareWallet)
        return this.disburseHardwareWallet({ neuronId: t3, toAccountId: n2, amount: o5 });
      let r = c(n2) ? w.fromHex(n2) : void 0, a = go({ neuronId: t3, toAccountIdentifier: r, amount: o5 });
      return h4({ request: a, service: this.certifiedService });
    });
    __publicField(this, "mergeMaturity", async ({ neuronId: t3, percentageToMerge: n2 }) => {
      if (ee(n2), this.hardwareWallet)
        return this.mergeMaturityHardwareWallet({ neuronId: t3, percentageToMerge: n2 });
      let o5 = Ro({ neuronId: t3, percentageToMerge: n2 });
      return h4({ request: o5, service: this.certifiedService });
    });
    __publicField(this, "stakeMaturity", async ({ neuronId: t3, percentageToStake: n2 }) => {
      ee(n2 ?? 100), await h4({ request: vo({ neuronId: t3, percentageToStake: n2 }), service: this.certifiedService });
    });
    __publicField(this, "spawnNeuron", async ({ neuronId: t3, percentageToSpawn: n2, newController: o5, nonce: r }) => {
      var _a;
      if (c(n2) && ee(n2), this.hardwareWallet)
        return this.spawnHardwareWallet({ neuronId: t3, percentageToSpawn: n2, newController: o5 == null ? void 0 : o5.toText() });
      let a = ho({ neuronId: t3, percentageToSpawn: n2, newController: o5, nonce: r }), i2 = await this.certifiedService.manage_neuron(a), c3 = xe2(i2), d4;
      if ("Spawn" in c3 && c(d4 = (_a = K(c3.Spawn.created_neuron_id)) == null ? void 0 : _a.id))
        return d4;
      throw new z(`Unrecognized Spawn error in ${JSON.stringify(i2)}`);
    });
    __publicField(this, "addHotkey", async ({ neuronId: t3, principal: n2 }) => {
      if (this.hardwareWallet)
        return this.addHotkeyHardwareWallet({ neuronId: t3, principal: n2 });
      let o5 = Oo({ neuronId: t3, principal: n2 });
      return h4({ request: o5, service: this.certifiedService });
    });
    __publicField(this, "removeHotkey", async ({ neuronId: t3, principal: n2 }) => {
      if (this.hardwareWallet)
        return this.removeHotkeyHardwareWallet({ neuronId: t3, principal: n2 });
      let o5 = So({ neuronId: t3, principal: n2 });
      return h4({ request: o5, service: this.certifiedService });
    });
    __publicField(this, "claimOrRefreshNeuronFromAccount", async ({ memo: t3, controller: n2 }) => {
      var _a;
      let o5 = mo({ memo: t3, controller: n2 }), r = await this.certifiedService.manage_neuron(o5), a;
      if (c(a = K(r.command)) && "ClaimOrRefresh" in a)
        return (_a = K(a.ClaimOrRefresh.refreshed_neuron_id)) == null ? void 0 : _a.id;
      throw new z(`Unrecognized ClaimOrRefresh error in ${JSON.stringify(r)}`);
    });
    __publicField(this, "claimOrRefreshNeuron", async (t3) => {
      var _a;
      let n2 = _o(t3), o5 = await this.service.manage_neuron(n2), r;
      if (c(r = K(o5.command)) && "ClaimOrRefresh" in r)
        return (_a = K(r.ClaimOrRefresh.refreshed_neuron_id)) == null ? void 0 : _a.id;
      throw new z(`Unrecognized ClaimOrRefresh error in ${JSON.stringify(o5)}`);
    });
    __publicField(this, "buildNeuronStakeSubAccount", (t3, n2) => {
      let o5 = se("neuron-stake"), r = tt.create();
      return r.update(xe([12, ...o5, ...n2.toUint8Array(), ...t3])), E2.fromBytes(r.digest());
    });
    __publicField(this, "getNeuron", async ({ certified: t3 = true, neuronId: n2 }) => {
      let [o5] = await this.listNeurons({ certified: t3, neuronIds: [n2] });
      return o5;
    });
    __publicField(this, "listNeuronsHardwareWallet", async () => {
      let { ListNeurons: t3, ListNeuronsResponse: n2 } = await p2(), o5 = new t3();
      o5.setIncludeNeuronsReadableByCaller(true);
      let r = await l({ agent: this.agent, canisterId: this.canisterId, methodName: "list_neurons_pb", arg: o5.serializeBinary() }), a = n2.deserializeBinary(r), i2 = a.getFullNeuronsList();
      return a.getNeuronIdsList().map(Io({ pbNeurons: i2, canisterId: this.canisterId }));
    });
    __publicField(this, "manageNeuronUpdateCall", async (t3) => {
      let n2 = await l({ agent: this.agent, canisterId: this.canisterId, methodName: "manage_neuron_pb", arg: t3.serializeBinary() });
      await Lo(n2);
    });
    __publicField(this, "addHotkeyHardwareWallet", async ({ neuronId: t3, principal: n2 }) => {
      let o5 = await Ao({ neuronId: t3, principal: n2.toText() });
      await this.manageNeuronUpdateCall(o5);
    });
    __publicField(this, "removeHotkeyHardwareWallet", async ({ neuronId: t3, principal: n2 }) => {
      let o5 = await Vo({ neuronId: t3, principal: n2.toText() });
      await this.manageNeuronUpdateCall(o5);
    });
    __publicField(this, "increaseDissolveDelayHardwareWallet", async ({ neuronId: t3, additionalDissolveDelaySeconds: n2 }) => {
      let o5 = await Eo({ neuronId: t3, additionalDissolveDelaySeconds: n2 });
      await this.manageNeuronUpdateCall(o5);
    });
    __publicField(this, "startDissolvingHardwareWallet", async (t3) => {
      let n2 = await Fo(t3);
      await this.manageNeuronUpdateCall(n2);
    });
    __publicField(this, "stopDissolvingHardwareWallet", async (t3) => {
      let n2 = await Bo(t3);
      await this.manageNeuronUpdateCall(n2);
    });
    __publicField(this, "joinCommunityFundHardwareWallet", async (t3) => {
      let n2 = await qo(t3);
      await this.manageNeuronUpdateCall(n2);
    });
    __publicField(this, "disburseHardwareWallet", async (t3) => {
      let n2 = await Uo(t3);
      await this.manageNeuronUpdateCall(n2);
    });
    __publicField(this, "mergeMaturityHardwareWallet", async (t3) => {
      let n2 = await Ko(t3);
      await this.manageNeuronUpdateCall(n2);
    });
    __publicField(this, "spawnHardwareWallet", async (t3) => {
      var _a;
      let n2 = await Ho(t3), o5 = await l({ agent: this.agent, canisterId: this.canisterId, methodName: "manage_neuron_pb", arg: n2.serializeBinary() }), { ManageNeuronResponse: r } = await p2(), a = r.deserializeBinary(o5), i2 = a.getError();
      if (i2)
        throw new P3({ error_message: i2.getErrorMessage(), error_type: i2.getErrorType() });
      let c3 = (_a = a.getSpawn()) == null ? void 0 : _a.getCreatedNeuronId();
      if (c(c3))
        return BigInt(c3.getId());
      throw new z(`Unrecognized Spawn error in ${JSON.stringify(a)}`);
    });
    this.canisterId = t3;
    this.service = n2;
    this.certifiedService = o5;
    this.agent = r;
    this.hardwareWallet = a;
    this.canisterId = t3, this.service = n2, this.certifiedService = o5, this.agent = r, this.hardwareWallet = a;
  }
  static create(t3 = {}) {
    let n2 = t3.canisterId ?? E, { service: o5, certifiedService: r, agent: a } = X({ options: { ...t3, canisterId: n2 }, idlFactory: eo, certifiedIdlFactory: Ln });
    return new Ge(n2, o5, r, a, t3.hardwareWallet);
  }
  getGovernanceService(t3) {
    return t3 ? this.certifiedService : this.service;
  }
};

// node_modules/@dfinity/nns/dist/esm/chunk-XJOUJJZM.js
var o4 = class {
  constructor(r, t3) {
    this.e8s = r;
    this.token = t3;
  }
  static fromE8s(r) {
    return new o4(r, $);
  }
  static fromString(r) {
    let t3 = k(r);
    return typeof t3 == "bigint" ? new o4(t3, $) : t3;
  }
  toE8s() {
    return this.e8s;
  }
  async toProto() {
    let { ICPTs: r } = await p2(), t3 = new r();
    return t3.setE8s(this.e8s.toString()), t3;
  }
};

// node_modules/@dfinity/nns/dist/esm/chunk-LRX366G2.js
var ee2 = ({ IDL: e2 }) => {
  let r = e2.Vec(e2.Nat8), c3 = e2.Record({ owner: e2.Principal, subaccount: e2.Opt(r) }), n2 = e2.Record({ maximum_number_of_accounts: e2.Opt(e2.Nat64), icrc1_minting_account: e2.Opt(c3) }), t3 = e2.Record({ e8s: e2.Nat64 }), a = e2.Text, d4 = e2.Record({ secs: e2.Nat64, nanos: e2.Nat32 }), f2 = e2.Record({ num_blocks_to_archive: e2.Nat64, trigger_threshold: e2.Nat64, max_message_size_bytes: e2.Opt(e2.Nat64), cycles_for_archive_creation: e2.Opt(e2.Nat64), node_max_memory_size_bytes: e2.Opt(e2.Nat64), controller_id: e2.Principal }), T3 = e2.Record({ send_whitelist: e2.Vec(e2.Principal), token_symbol: e2.Opt(e2.Text), transfer_fee: e2.Opt(t3), minting_account: a, transaction_window: e2.Opt(d4), max_message_size_bytes: e2.Opt(e2.Nat64), icrc1_minting_account: e2.Opt(c3), archive_options: e2.Opt(f2), initial_values: e2.Vec(e2.Tuple(a, t3)), token_name: e2.Opt(e2.Text) }), P4 = e2.Variant({ Upgrade: e2.Opt(n2), Init: T3 }), o5 = e2.Nat64, y = e2.Record({ start: o5, length: e2.Nat64 }), u3 = e2.Nat64, i2 = e2.Vec(e2.Nat8), l3 = e2.Record({ timestamp_nanos: e2.Nat64 }), s2 = e2.Variant({ Approve: e2.Record({ fee: t3, from: i2, allowance_e8s: e2.Int, expires_at: e2.Opt(l3), spender: i2 }), Burn: e2.Record({ from: i2, amount: t3 }), Mint: e2.Record({ to: i2, amount: t3 }), Transfer: e2.Record({ to: i2, fee: t3, from: i2, amount: t3 }), TransferFrom: e2.Record({ to: i2, fee: t3, from: i2, amount: t3, spender: i2 }) }), S2 = e2.Record({ memo: u3, icrc1_memo: e2.Opt(e2.Vec(e2.Nat8)), operation: e2.Opt(s2), created_at_time: l3 }), x2 = e2.Record({ transaction: S2, timestamp: l3, parent_hash: e2.Opt(e2.Vec(e2.Nat8)) }), q3 = e2.Record({ blocks: e2.Vec(x2) }), O = e2.Variant({ BadFirstBlockIndex: e2.Record({ requested_index: o5, first_valid_index: o5 }), Other: e2.Record({ error_message: e2.Text, error_code: e2.Nat64 }) }), C2 = e2.Variant({ Ok: q3, Err: O }), E5 = e2.Func([y], [C2], []), m4 = e2.Record({ certificate: e2.Opt(e2.Vec(e2.Nat8)), blocks: e2.Vec(x2), chain_length: e2.Nat64, first_block_index: o5, archived_blocks: e2.Vec(e2.Record({ callback: E5, start: o5, length: e2.Nat64 })) }), h5 = e2.Record({ account: i2 }), b3 = e2.Record({ account: a }), g3 = e2.Record({ canister_id: e2.Principal }), U3 = e2.Record({ archives: e2.Vec(g3) }), p5 = e2.Nat, F3 = e2.Variant({ Int: e2.Int, Nat: e2.Nat, Blob: e2.Vec(e2.Nat8), Text: e2.Text }), z2 = e2.Nat64, H2 = e2.Record({ to: c3, fee: e2.Opt(p5), memo: e2.Opt(e2.Vec(e2.Nat8)), from_subaccount: e2.Opt(r), created_at_time: e2.Opt(z2), amount: p5 }), w2 = e2.Nat, M = e2.Variant({ GenericError: e2.Record({ message: e2.Text, error_code: e2.Nat }), TemporarilyUnavailable: e2.Null, BadBurn: e2.Record({ min_burn_amount: p5 }), Duplicate: e2.Record({ duplicate_of: w2 }), BadFee: e2.Record({ expected_fee: p5 }), CreatedInFuture: e2.Record({ ledger_time: e2.Nat64 }), TooOld: e2.Null, InsufficientFunds: e2.Record({ balance: p5 }) }), W = e2.Variant({ Ok: w2, Err: M }), Q = e2.Record({ to: a, fee: t3, memo: u3, from_subaccount: e2.Opt(r), created_at_time: e2.Opt(l3), amount: t3 }), G2 = e2.Record({ to: i2, fee: t3, memo: u3, from_subaccount: e2.Opt(r), created_at_time: e2.Opt(l3), amount: t3 }), j3 = e2.Variant({ TxTooOld: e2.Record({ allowed_window_nanos: e2.Nat64 }), BadFee: e2.Record({ expected_fee: t3 }), TxDuplicate: e2.Record({ duplicate_of: o5 }), TxCreatedInFuture: e2.Null, InsufficientFunds: e2.Record({ balance: t3 }) }), J3 = e2.Variant({ Ok: o5, Err: j3 }), $5 = e2.Record({}), K3 = e2.Record({ transfer_fee: t3 });
  return e2.Service({ _blocks: e2.Func([y], [m4], []), account_balance: e2.Func([h5], [t3], []), account_balance_dfx: e2.Func([b3], [t3], []), archives: e2.Func([], [U3], []), decimals: e2.Func([], [e2.Record({ decimals: e2.Nat32 })], []), icrc1_balance_of: e2.Func([c3], [p5], []), icrc1_decimals: e2.Func([], [e2.Nat8], []), icrc1_fee: e2.Func([], [p5], []), icrc1_metadata: e2.Func([], [e2.Vec(e2.Tuple(e2.Text, F3))], []), icrc1_minting_account: e2.Func([], [e2.Opt(c3)], []), icrc1_name: e2.Func([], [e2.Text], []), icrc1_supported_standards: e2.Func([], [e2.Vec(e2.Record({ url: e2.Text, name: e2.Text }))], []), icrc1_symbol: e2.Func([], [e2.Text], []), icrc1_total_supply: e2.Func([], [p5], []), icrc1_transfer: e2.Func([H2], [W], []), name: e2.Func([], [e2.Record({ name: e2.Text })], []), send_dfx: e2.Func([Q], [o5], []), symbol: e2.Func([], [e2.Record({ symbol: e2.Text })], []), transfer: e2.Func([G2], [J3], []), transfer_fee: e2.Func([$5], [K3], []) });
};
var te = ({ IDL: e2 }) => {
  let r = e2.Vec(e2.Nat8), c3 = e2.Record({ owner: e2.Principal, subaccount: e2.Opt(r) }), n2 = e2.Record({ maximum_number_of_accounts: e2.Opt(e2.Nat64), icrc1_minting_account: e2.Opt(c3) }), t3 = e2.Record({ e8s: e2.Nat64 }), a = e2.Text, d4 = e2.Record({ secs: e2.Nat64, nanos: e2.Nat32 }), f2 = e2.Record({ num_blocks_to_archive: e2.Nat64, trigger_threshold: e2.Nat64, max_message_size_bytes: e2.Opt(e2.Nat64), cycles_for_archive_creation: e2.Opt(e2.Nat64), node_max_memory_size_bytes: e2.Opt(e2.Nat64), controller_id: e2.Principal }), T3 = e2.Record({ send_whitelist: e2.Vec(e2.Principal), token_symbol: e2.Opt(e2.Text), transfer_fee: e2.Opt(t3), minting_account: a, transaction_window: e2.Opt(d4), max_message_size_bytes: e2.Opt(e2.Nat64), icrc1_minting_account: e2.Opt(c3), archive_options: e2.Opt(f2), initial_values: e2.Vec(e2.Tuple(a, t3)), token_name: e2.Opt(e2.Text) }), P4 = e2.Variant({ Upgrade: e2.Opt(n2), Init: T3 }), o5 = e2.Vec(e2.Nat8), y = e2.Record({ account: o5 }), u3 = e2.Record({ account: a }), i2 = e2.Record({ canister_id: e2.Principal }), l3 = e2.Record({ archives: e2.Vec(i2) }), s2 = e2.Nat, S2 = e2.Variant({ Int: e2.Int, Nat: e2.Nat, Blob: e2.Vec(e2.Nat8), Text: e2.Text }), x2 = e2.Nat64, q3 = e2.Record({ to: c3, fee: e2.Opt(s2), memo: e2.Opt(e2.Vec(e2.Nat8)), from_subaccount: e2.Opt(r), created_at_time: e2.Opt(x2), amount: s2 }), O = e2.Nat, C2 = e2.Variant({ GenericError: e2.Record({ message: e2.Text, error_code: e2.Nat }), TemporarilyUnavailable: e2.Null, BadBurn: e2.Record({ min_burn_amount: s2 }), Duplicate: e2.Record({ duplicate_of: O }), BadFee: e2.Record({ expected_fee: s2 }), CreatedInFuture: e2.Record({ ledger_time: e2.Nat64 }), TooOld: e2.Null, InsufficientFunds: e2.Record({ balance: s2 }) }), E5 = e2.Variant({ Ok: O, Err: C2 }), m4 = e2.Nat64, h5 = e2.Record({ start: m4, length: e2.Nat64 }), b3 = e2.Nat64, g3 = e2.Record({ timestamp_nanos: e2.Nat64 }), U3 = e2.Variant({ Approve: e2.Record({ fee: t3, from: o5, allowance_e8s: e2.Int, expires_at: e2.Opt(g3), spender: o5 }), Burn: e2.Record({ from: o5, amount: t3 }), Mint: e2.Record({ to: o5, amount: t3 }), Transfer: e2.Record({ to: o5, fee: t3, from: o5, amount: t3 }), TransferFrom: e2.Record({ to: o5, fee: t3, from: o5, amount: t3, spender: o5 }) }), p5 = e2.Record({ memo: b3, icrc1_memo: e2.Opt(e2.Vec(e2.Nat8)), operation: e2.Opt(U3), created_at_time: g3 }), F3 = e2.Record({ transaction: p5, timestamp: g3, parent_hash: e2.Opt(e2.Vec(e2.Nat8)) }), z2 = e2.Record({ blocks: e2.Vec(F3) }), H2 = e2.Variant({ BadFirstBlockIndex: e2.Record({ requested_index: m4, first_valid_index: m4 }), Other: e2.Record({ error_message: e2.Text, error_code: e2.Nat64 }) }), w2 = e2.Variant({ Ok: z2, Err: H2 }), M = e2.Func([h5], [w2], ["query"]), W = e2.Record({ certificate: e2.Opt(e2.Vec(e2.Nat8)), blocks: e2.Vec(F3), chain_length: e2.Nat64, first_block_index: m4, archived_blocks: e2.Vec(e2.Record({ callback: M, start: m4, length: e2.Nat64 })) }), Q = e2.Record({ to: a, fee: t3, memo: b3, from_subaccount: e2.Opt(r), created_at_time: e2.Opt(g3), amount: t3 }), G2 = e2.Record({ to: o5, fee: t3, memo: b3, from_subaccount: e2.Opt(r), created_at_time: e2.Opt(g3), amount: t3 }), j3 = e2.Variant({ TxTooOld: e2.Record({ allowed_window_nanos: e2.Nat64 }), BadFee: e2.Record({ expected_fee: t3 }), TxDuplicate: e2.Record({ duplicate_of: m4 }), TxCreatedInFuture: e2.Null, InsufficientFunds: e2.Record({ balance: t3 }) }), J3 = e2.Variant({ Ok: m4, Err: j3 }), $5 = e2.Record({}), K3 = e2.Record({ transfer_fee: t3 });
  return e2.Service({ account_balance: e2.Func([y], [t3], ["query"]), account_balance_dfx: e2.Func([u3], [t3], ["query"]), archives: e2.Func([], [l3], ["query"]), decimals: e2.Func([], [e2.Record({ decimals: e2.Nat32 })], ["query"]), icrc1_balance_of: e2.Func([c3], [s2], ["query"]), icrc1_decimals: e2.Func([], [e2.Nat8], ["query"]), icrc1_fee: e2.Func([], [s2], ["query"]), icrc1_metadata: e2.Func([], [e2.Vec(e2.Tuple(e2.Text, S2))], ["query"]), icrc1_minting_account: e2.Func([], [e2.Opt(c3)], ["query"]), icrc1_name: e2.Func([], [e2.Text], ["query"]), icrc1_supported_standards: e2.Func([], [e2.Vec(e2.Record({ url: e2.Text, name: e2.Text }))], ["query"]), icrc1_symbol: e2.Func([], [e2.Text], ["query"]), icrc1_total_supply: e2.Func([], [s2], ["query"]), icrc1_transfer: e2.Func([q3], [E5], []), name: e2.Func([], [e2.Record({ name: e2.Text })], ["query"]), query_blocks: e2.Func([h5], [W], ["query"]), send_dfx: e2.Func([Q], [m4], []), symbol: e2.Func([], [e2.Record({ symbol: e2.Text })], ["query"]), transfer: e2.Func([G2], [J3], []), transfer_fee: e2.Func([$5], [K3], ["query"]) });
};
var ce2 = async (e2) => {
  let r = new Uint8Array(e2).buffer, { Subaccount: c3 } = await p2(), n2 = new c3();
  return n2.setSubAccount(new Uint8Array(r)), n2;
};
var X3 = async (e2) => {
  let { ICPTs: r } = await p2(), c3 = new r();
  return c3.setE8s(e2.toString(10)), c3;
};
var re = (e2) => ({ e8s: e2 });
var ne2 = ({ to: e2, amount: r, memo: c3, fee: n2, fromSubAccount: t3, createdAt: a }) => ({ to: e2.toUint8Array(), fee: re(n2 ?? _2), amount: re(r), memo: c3 ?? BigInt(0), created_at_time: a !== void 0 ? [{ timestamp_nanos: a }] : [], from_subaccount: t3 === void 0 ? [] : [xe(t3)] });
var _3 = class extends Error {
};
var Y2 = class extends _3 {
};
var A3 = class extends _3 {
  constructor(c3) {
    super();
    this.balance = c3;
  }
};
var v3 = class extends _3 {
  constructor(c3) {
    super();
    this.allowed_window_secs = c3;
  }
};
var k3 = class extends _3 {
};
var V2 = class extends _3 {
  constructor(c3) {
    super();
    this.duplicateOf = c3;
  }
};
var Z = class extends _3 {
  constructor(c3) {
    super();
    this.expectedFee = c3;
  }
};
var oe = (e2) => "TxDuplicate" in e2 ? new V2(e2.TxDuplicate.duplicate_of) : "InsufficientFunds" in e2 ? new A3(e2.InsufficientFunds.balance.e8s) : "TxCreatedInFuture" in e2 ? new k3() : "TxTooOld" in e2 ? new v3(Number(e2.TxTooOld.allowed_window_nanos)) : "BadFee" in e2 ? new Z(e2.BadFee.expected_fee.e8s) : new _3(`Unknown error type ${JSON.stringify(e2)}`);
var ae2 = (e2) => {
  let { message: r } = e2;
  if (r.includes("Reject code: 5")) {
    if (r.match(/Sending from (.*) is not allowed/))
      return new Y2();
    {
      let c3 = r.match(/transaction.*duplicate.* in block (\d+)/);
      if (c3 && c3.length > 1)
        return new V2(BigInt(c3[1]));
    }
    {
      let c3 = r.match(/debit account.*, current balance: (\d*(\.\d*)?)/);
      if (c3 && c3.length > 1) {
        let n2 = k(c3[1]);
        if (typeof n2 == "bigint")
          return new A3(n2);
      }
    }
    if (r.includes("is in future"))
      return new k3();
    {
      let c3 = r.match(/older than (\d+)/);
      if (c3 && c3.length > 1)
        return new v3(Number.parseInt(c3[1]));
    }
  }
  throw e2;
};
var B2 = class {
  constructor(r, c3, n2, t3, a, d4, f2 = false) {
    __publicField(this, "accountBalance", async ({ accountIdentifier: r, certified: c3 = true }) => this.hardwareWallet ? this.accountBalanceHardwareWallet({ accountIdentifier: r, certified: c3 }) : (await (c3 ? this.certifiedService : this.service).account_balance({ account: r.toUint8Array() })).e8s);
    __publicField(this, "transactionFee", async () => {
      let { transfer_fee: { e8s: r } } = await this.service.transfer_fee({});
      return r;
    });
    __publicField(this, "transfer", async (r) => {
      if (this.hardwareWallet)
        return this.transferHardwareWallet(r);
      r.fee === void 0 && (r.fee = this.hardwareWallet ? _2 : await this.transactionFee());
      let c3 = ne2(r), n2 = await this.certifiedService.transfer(c3);
      if ("Err" in n2)
        throw oe(n2.Err);
      return n2.Ok;
    });
    __publicField(this, "accountBalanceHardwareWallet", async ({ accountIdentifier: r, certified: c3 = true }) => {
      let n2 = c3 ? this.updateFetcher : this.queryFetcher, { AccountBalanceRequest: t3, ICPTs: a } = await p2(), d4 = new t3();
      d4.setAccount(await r.toProto());
      let f2 = await n2({ agent: this.agent, canisterId: this.canisterId, methodName: "account_balance_pb", arg: d4.serializeBinary() });
      return BigInt(a.deserializeBinary(new Uint8Array(f2)).getE8s());
    });
    __publicField(this, "transferHardwareWallet", async ({ to: r, amount: c3, memo: n2, fee: t3, fromSubAccount: a, createdAt: d4 }) => {
      let { SendRequest: f2, Payment: T3, Memo: P4, TimeStamp: o5, BlockHeight: y } = await p2(), u3 = new f2();
      u3.setTo(await r.toProto());
      let i2 = new T3();
      i2.setReceiverGets(await X3(c3)), u3.setPayment(i2), u3.setMaxFee(await X3(t3 ?? _2));
      let l3 = new P4();
      if (l3.setMemo((n2 ?? BigInt(0)).toString()), u3.setMemo(l3), d4 !== void 0) {
        let s2 = new o5();
        s2.setTimestampNanos(d4.toString()), u3.setCreatedAtTime(s2);
      }
      a !== void 0 && u3.setFromSubaccount(await ce2(a));
      try {
        let s2 = await this.updateFetcher({ agent: this.agent, canisterId: this.canisterId, methodName: "send_pb", arg: u3.serializeBinary() });
        return BigInt(y.deserializeBinary(s2).getHeight());
      } catch (s2) {
        throw s2 instanceof Error ? ae2(s2) : s2;
      }
    });
    this.agent = r;
    this.canisterId = c3;
    this.service = n2;
    this.certifiedService = t3;
    this.updateFetcher = a;
    this.queryFetcher = d4;
    this.hardwareWallet = f2;
  }
  static create(r = {}) {
    let c3 = r.canisterId ?? o, { service: n2, certifiedService: t3, agent: a } = X({ options: { ...r, canisterId: c3 }, idlFactory: te, certifiedIdlFactory: ee2 });
    return new B2(a, c3, n2, t3, r.updateCallOverride ?? l, r.queryCallOverride ?? u2, r.hardwareWallet);
  }
};

// node_modules/@dfinity/nns/dist/esm/chunk-FTOSOLE4.js
var Z2 = ({ IDL: e2 }) => {
  let r = e2.Record({ allowed_principals: e2.Vec(e2.Principal), access_controls_enabled: e2.Bool, sns_subnet_ids: e2.Vec(e2.Principal) }), n2 = e2.Record({ wasm: e2.Vec(e2.Nat8), canister_type: e2.Int32 }), i2 = e2.Record({ hash: e2.Vec(e2.Nat8), wasm: e2.Opt(n2) }), s2 = e2.Record({ message: e2.Text }), _4 = e2.Variant({ Error: s2, Hash: e2.Vec(e2.Nat8) }), d4 = e2.Record({ result: e2.Opt(_4) }), l3 = e2.Record({ dissolve_delay_interval_seconds: e2.Nat64, count: e2.Nat64 }), a = e2.Record({ id: e2.Opt(e2.Principal) }), u3 = e2.Record({ canisters: e2.Vec(a) }), O = e2.Record({ nns_neuron_id: e2.Nat64, amount_icp_e8s: e2.Nat64 }), R = e2.Record({ hotkey_principal: e2.Text, cf_neurons: e2.Vec(O) }), m4 = e2.Record({ participants: e2.Vec(R) }), N4 = e2.Record({ total_e8s: e2.Nat64 }), o5 = e2.Record({ controller: e2.Opt(e2.Principal), dissolve_delay_seconds: e2.Nat64, memo: e2.Nat64, stake_e8s: e2.Nat64, vesting_period_seconds: e2.Opt(e2.Nat64) }), w2 = e2.Record({ developer_neurons: e2.Vec(o5) }), P4 = e2.Record({ airdrop_neurons: e2.Vec(o5) }), V3 = e2.Record({ total_e8s: e2.Nat64, initial_swap_amount_e8s: e2.Nat64 }), v4 = e2.Record({ treasury_distribution: e2.Opt(N4), developer_distribution: e2.Opt(w2), airdrop_distribution: e2.Opt(P4), swap_distribution: e2.Opt(V3) }), x2 = e2.Variant({ FractionalDeveloperVotingPower: v4 }), g3 = e2.Record({ iso_codes: e2.Vec(e2.Text) }), h5 = e2.Record({ url: e2.Opt(e2.Text), max_dissolve_delay_seconds: e2.Opt(e2.Nat64), max_dissolve_delay_bonus_percentage: e2.Opt(e2.Nat64), nns_proposal_id: e2.Opt(e2.Nat64), min_participant_icp_e8s: e2.Opt(e2.Nat64), neuron_basket_construction_parameters: e2.Opt(l3), fallback_controller_principal_ids: e2.Vec(e2.Text), token_symbol: e2.Opt(e2.Text), final_reward_rate_basis_points: e2.Opt(e2.Nat64), max_icp_e8s: e2.Opt(e2.Nat64), neuron_minimum_stake_e8s: e2.Opt(e2.Nat64), confirmation_text: e2.Opt(e2.Text), logo: e2.Opt(e2.Text), name: e2.Opt(e2.Text), swap_start_timestamp_seconds: e2.Opt(e2.Nat64), swap_due_timestamp_seconds: e2.Opt(e2.Nat64), initial_voting_period_seconds: e2.Opt(e2.Nat64), neuron_minimum_dissolve_delay_to_vote_seconds: e2.Opt(e2.Nat64), description: e2.Opt(e2.Text), max_neuron_age_seconds_for_age_bonus: e2.Opt(e2.Nat64), min_participants: e2.Opt(e2.Nat64), initial_reward_rate_basis_points: e2.Opt(e2.Nat64), wait_for_quiet_deadline_increase_seconds: e2.Opt(e2.Nat64), transaction_fee_e8s: e2.Opt(e2.Nat64), dapp_canisters: e2.Opt(u3), neurons_fund_participants: e2.Opt(m4), max_age_bonus_percentage: e2.Opt(e2.Nat64), initial_token_distribution: e2.Opt(x2), reward_rate_transition_duration_seconds: e2.Opt(e2.Nat64), token_logo: e2.Opt(e2.Text), token_name: e2.Opt(e2.Text), max_participant_icp_e8s: e2.Opt(e2.Nat64), proposal_reject_cost_e8s: e2.Opt(e2.Nat64), restricted_countries: e2.Opt(g3), min_icp_e8s: e2.Opt(e2.Nat64) }), S2 = e2.Record({ sns_init_payload: e2.Opt(h5) }), y = e2.Record({ restored_dapp_canisters: e2.Vec(a), nns_controlled_dapp_canisters: e2.Vec(a), sns_controlled_dapp_canisters: e2.Vec(a) }), b3 = e2.Record({ root: e2.Opt(e2.Principal), swap: e2.Opt(e2.Principal), ledger: e2.Opt(e2.Principal), index: e2.Opt(e2.Principal), governance: e2.Opt(e2.Principal) }), T3 = e2.Record({ dapp_canisters_transfer_result: e2.Opt(y), subnet_id: e2.Opt(e2.Principal), error: e2.Opt(s2), canisters: e2.Opt(b3) }), c3 = e2.Record({ allowed_principals: e2.Vec(e2.Principal) }), t3 = e2.Record({ archive_wasm_hash: e2.Vec(e2.Nat8), root_wasm_hash: e2.Vec(e2.Nat8), swap_wasm_hash: e2.Vec(e2.Nat8), ledger_wasm_hash: e2.Vec(e2.Nat8), governance_wasm_hash: e2.Vec(e2.Nat8), index_wasm_hash: e2.Vec(e2.Nat8) }), F3 = e2.Record({ governance_canister_id: e2.Opt(e2.Principal), current_version: e2.Opt(t3) }), f2 = e2.Record({ next_version: e2.Opt(t3) }), q3 = e2.Record({ sns_subnet_ids: e2.Vec(e2.Principal) }), C2 = e2.Record({ hash: e2.Vec(e2.Nat8) }), k4 = e2.Record({ wasm: e2.Opt(n2) }), U3 = e2.Record({ next_version: e2.Opt(t3), current_version: e2.Opt(t3) }), W = e2.Record({ upgrade_path: e2.Vec(U3), sns_governance_canister_id: e2.Opt(e2.Principal) }), A4 = e2.Record({ error: e2.Opt(s2) }), E5 = e2.Record({ root_canister_id: e2.Opt(e2.Principal), governance_canister_id: e2.Opt(e2.Principal), index_canister_id: e2.Opt(e2.Principal), swap_canister_id: e2.Opt(e2.Principal), ledger_canister_id: e2.Opt(e2.Principal) }), G2 = e2.Record({ instances: e2.Vec(E5) }), B3 = e2.Record({ limit: e2.Nat32, starting_at: e2.Opt(t3), sns_governance_canister_id: e2.Opt(e2.Principal) }), j3 = e2.Record({ archive_wasm_hash: e2.Text, root_wasm_hash: e2.Text, swap_wasm_hash: e2.Text, ledger_wasm_hash: e2.Text, governance_wasm_hash: e2.Text, index_wasm_hash: e2.Text }), H2 = e2.Record({ pretty_version: e2.Opt(j3), version: e2.Opt(t3) }), M = e2.Record({ steps: e2.Vec(H2) }), z2 = e2.Record({ added_principals: e2.Vec(e2.Principal), removed_principals: e2.Vec(e2.Principal) }), J3 = e2.Variant({ Error: s2, AllowedPrincipals: c3 }), K3 = e2.Record({ update_allowed_principals_result: e2.Opt(J3) }), Q = e2.Record({ sns_subnet_ids_to_add: e2.Vec(e2.Principal), sns_subnet_ids_to_remove: e2.Vec(e2.Principal) }), X4 = e2.Record({ error: e2.Opt(s2) });
  return e2.Service({ add_wasm: e2.Func([i2], [d4], []), deploy_new_sns: e2.Func([S2], [T3], []), get_allowed_principals: e2.Func([e2.Record({})], [c3], []), get_latest_sns_version_pretty: e2.Func([e2.Null], [e2.Vec(e2.Tuple(e2.Text, e2.Text))], []), get_next_sns_version: e2.Func([F3], [f2], []), get_sns_subnet_ids: e2.Func([e2.Record({})], [q3], []), get_wasm: e2.Func([C2], [k4], []), insert_upgrade_path_entries: e2.Func([W], [A4], []), list_deployed_snses: e2.Func([e2.Record({})], [G2], []), list_upgrade_steps: e2.Func([B3], [M], []), update_allowed_principals: e2.Func([z2], [K3], []), update_sns_subnet_list: e2.Func([Q], [X4], []) });
};
var $4 = ({ IDL: e2 }) => {
  let r = e2.Record({ allowed_principals: e2.Vec(e2.Principal), access_controls_enabled: e2.Bool, sns_subnet_ids: e2.Vec(e2.Principal) }), n2 = e2.Record({ wasm: e2.Vec(e2.Nat8), canister_type: e2.Int32 }), i2 = e2.Record({ hash: e2.Vec(e2.Nat8), wasm: e2.Opt(n2) }), s2 = e2.Record({ message: e2.Text }), _4 = e2.Variant({ Error: s2, Hash: e2.Vec(e2.Nat8) }), d4 = e2.Record({ result: e2.Opt(_4) }), l3 = e2.Record({ dissolve_delay_interval_seconds: e2.Nat64, count: e2.Nat64 }), a = e2.Record({ id: e2.Opt(e2.Principal) }), u3 = e2.Record({ canisters: e2.Vec(a) }), O = e2.Record({ nns_neuron_id: e2.Nat64, amount_icp_e8s: e2.Nat64 }), R = e2.Record({ hotkey_principal: e2.Text, cf_neurons: e2.Vec(O) }), m4 = e2.Record({ participants: e2.Vec(R) }), N4 = e2.Record({ total_e8s: e2.Nat64 }), o5 = e2.Record({ controller: e2.Opt(e2.Principal), dissolve_delay_seconds: e2.Nat64, memo: e2.Nat64, stake_e8s: e2.Nat64, vesting_period_seconds: e2.Opt(e2.Nat64) }), w2 = e2.Record({ developer_neurons: e2.Vec(o5) }), P4 = e2.Record({ airdrop_neurons: e2.Vec(o5) }), V3 = e2.Record({ total_e8s: e2.Nat64, initial_swap_amount_e8s: e2.Nat64 }), v4 = e2.Record({ treasury_distribution: e2.Opt(N4), developer_distribution: e2.Opt(w2), airdrop_distribution: e2.Opt(P4), swap_distribution: e2.Opt(V3) }), x2 = e2.Variant({ FractionalDeveloperVotingPower: v4 }), g3 = e2.Record({ iso_codes: e2.Vec(e2.Text) }), h5 = e2.Record({ url: e2.Opt(e2.Text), max_dissolve_delay_seconds: e2.Opt(e2.Nat64), max_dissolve_delay_bonus_percentage: e2.Opt(e2.Nat64), nns_proposal_id: e2.Opt(e2.Nat64), min_participant_icp_e8s: e2.Opt(e2.Nat64), neuron_basket_construction_parameters: e2.Opt(l3), fallback_controller_principal_ids: e2.Vec(e2.Text), token_symbol: e2.Opt(e2.Text), final_reward_rate_basis_points: e2.Opt(e2.Nat64), max_icp_e8s: e2.Opt(e2.Nat64), neuron_minimum_stake_e8s: e2.Opt(e2.Nat64), confirmation_text: e2.Opt(e2.Text), logo: e2.Opt(e2.Text), name: e2.Opt(e2.Text), swap_start_timestamp_seconds: e2.Opt(e2.Nat64), swap_due_timestamp_seconds: e2.Opt(e2.Nat64), initial_voting_period_seconds: e2.Opt(e2.Nat64), neuron_minimum_dissolve_delay_to_vote_seconds: e2.Opt(e2.Nat64), description: e2.Opt(e2.Text), max_neuron_age_seconds_for_age_bonus: e2.Opt(e2.Nat64), min_participants: e2.Opt(e2.Nat64), initial_reward_rate_basis_points: e2.Opt(e2.Nat64), wait_for_quiet_deadline_increase_seconds: e2.Opt(e2.Nat64), transaction_fee_e8s: e2.Opt(e2.Nat64), dapp_canisters: e2.Opt(u3), neurons_fund_participants: e2.Opt(m4), max_age_bonus_percentage: e2.Opt(e2.Nat64), initial_token_distribution: e2.Opt(x2), reward_rate_transition_duration_seconds: e2.Opt(e2.Nat64), token_logo: e2.Opt(e2.Text), token_name: e2.Opt(e2.Text), max_participant_icp_e8s: e2.Opt(e2.Nat64), proposal_reject_cost_e8s: e2.Opt(e2.Nat64), restricted_countries: e2.Opt(g3), min_icp_e8s: e2.Opt(e2.Nat64) }), S2 = e2.Record({ sns_init_payload: e2.Opt(h5) }), y = e2.Record({ restored_dapp_canisters: e2.Vec(a), nns_controlled_dapp_canisters: e2.Vec(a), sns_controlled_dapp_canisters: e2.Vec(a) }), b3 = e2.Record({ root: e2.Opt(e2.Principal), swap: e2.Opt(e2.Principal), ledger: e2.Opt(e2.Principal), index: e2.Opt(e2.Principal), governance: e2.Opt(e2.Principal) }), T3 = e2.Record({ dapp_canisters_transfer_result: e2.Opt(y), subnet_id: e2.Opt(e2.Principal), error: e2.Opt(s2), canisters: e2.Opt(b3) }), c3 = e2.Record({ allowed_principals: e2.Vec(e2.Principal) }), t3 = e2.Record({ archive_wasm_hash: e2.Vec(e2.Nat8), root_wasm_hash: e2.Vec(e2.Nat8), swap_wasm_hash: e2.Vec(e2.Nat8), ledger_wasm_hash: e2.Vec(e2.Nat8), governance_wasm_hash: e2.Vec(e2.Nat8), index_wasm_hash: e2.Vec(e2.Nat8) }), F3 = e2.Record({ governance_canister_id: e2.Opt(e2.Principal), current_version: e2.Opt(t3) }), f2 = e2.Record({ next_version: e2.Opt(t3) }), q3 = e2.Record({ sns_subnet_ids: e2.Vec(e2.Principal) }), C2 = e2.Record({ hash: e2.Vec(e2.Nat8) }), k4 = e2.Record({ wasm: e2.Opt(n2) }), U3 = e2.Record({ next_version: e2.Opt(t3), current_version: e2.Opt(t3) }), W = e2.Record({ upgrade_path: e2.Vec(U3), sns_governance_canister_id: e2.Opt(e2.Principal) }), A4 = e2.Record({ error: e2.Opt(s2) }), E5 = e2.Record({ root_canister_id: e2.Opt(e2.Principal), governance_canister_id: e2.Opt(e2.Principal), index_canister_id: e2.Opt(e2.Principal), swap_canister_id: e2.Opt(e2.Principal), ledger_canister_id: e2.Opt(e2.Principal) }), G2 = e2.Record({ instances: e2.Vec(E5) }), B3 = e2.Record({ limit: e2.Nat32, starting_at: e2.Opt(t3), sns_governance_canister_id: e2.Opt(e2.Principal) }), j3 = e2.Record({ archive_wasm_hash: e2.Text, root_wasm_hash: e2.Text, swap_wasm_hash: e2.Text, ledger_wasm_hash: e2.Text, governance_wasm_hash: e2.Text, index_wasm_hash: e2.Text }), H2 = e2.Record({ pretty_version: e2.Opt(j3), version: e2.Opt(t3) }), M = e2.Record({ steps: e2.Vec(H2) }), z2 = e2.Record({ added_principals: e2.Vec(e2.Principal), removed_principals: e2.Vec(e2.Principal) }), J3 = e2.Variant({ Error: s2, AllowedPrincipals: c3 }), K3 = e2.Record({ update_allowed_principals_result: e2.Opt(J3) }), Q = e2.Record({ sns_subnet_ids_to_add: e2.Vec(e2.Principal), sns_subnet_ids_to_remove: e2.Vec(e2.Principal) }), X4 = e2.Record({ error: e2.Opt(s2) });
  return e2.Service({ add_wasm: e2.Func([i2], [d4], []), deploy_new_sns: e2.Func([S2], [T3], []), get_allowed_principals: e2.Func([e2.Record({})], [c3], ["query"]), get_latest_sns_version_pretty: e2.Func([e2.Null], [e2.Vec(e2.Tuple(e2.Text, e2.Text))], ["query"]), get_next_sns_version: e2.Func([F3], [f2], ["query"]), get_sns_subnet_ids: e2.Func([e2.Record({})], [q3], ["query"]), get_wasm: e2.Func([C2], [k4], ["query"]), insert_upgrade_path_entries: e2.Func([W], [A4], []), list_deployed_snses: e2.Func([e2.Record({})], [G2], ["query"]), list_upgrade_steps: e2.Func([B3], [M], ["query"]), update_allowed_principals: e2.Func([z2], [K3], []), update_sns_subnet_list: e2.Func([Q], [X4], []) });
};
var p4 = class {
  constructor(r, n2) {
    __publicField(this, "listSnses", async ({ certified: r = true }) => {
      let n2 = r ? this.certifiedService : this.service, { instances: i2 } = await n2.list_deployed_snses({});
      return i2;
    });
    this.service = r;
    this.certifiedService = n2;
  }
  static create(r = {}) {
    let { service: n2, certifiedService: i2 } = X({ options: { ...r, canisterId: r.canisterId ?? _ }, idlFactory: $4, certifiedIdlFactory: Z2 });
    return new p4(n2, i2);
  }
};

// node_modules/@dfinity/nns/dist/esm/index.js
var f = ({ recentBallots: e2, proposalId: o5 }) => {
  var _a;
  return o5 ? (_a = e2.find(({ proposalId: r }) => r === o5)) == null ? void 0 : _a.vote : void 0;
};
var N3 = ({ neurons: e2, proposal: o5 }) => {
  let { ballots: n2, proposalTimestampSeconds: r } = o5;
  return e2.filter(({ createdTimestampSeconds: t3, neuronId: s2 }) => {
    let p5 = t3 > r, a = n2.find(({ neuronId: l3 }) => l3 === s2) === void 0;
    return p5 || a;
  });
};
var J2 = ({ neurons: e2, proposal: o5 }) => {
  let { id: n2 } = o5;
  return e2.filter(({ recentBallots: r, neuronId: t3 }) => f({ recentBallots: r, proposalId: n2 }) === void 0 && N3({ neurons: e2, proposal: o5 }).find(({ neuronId: s2 }) => s2 === t3) === void 0);
};
var K2 = ({ neurons: e2, proposal: { id: o5 } }) => e2.filter(({ recentBallots: n2 }) => f({ recentBallots: n2, proposalId: o5 }) !== void 0);
export {
  w as AccountIdentifier,
  Z as BadFeeError,
  Fe as CouldNotClaimNeuronError,
  qe as FeatureNotSupportedError,
  c2 as GenesisTokenCanister,
  Ge as GovernanceCanister,
  P3 as GovernanceError,
  o4 as ICP,
  Be2 as InsufficientAmountError,
  A3 as InsufficientFundsError,
  be as InvalidAccountIDError,
  Y2 as InvalidSenderError,
  B2 as LedgerCanister,
  Wo as NeuronState,
  pa as NnsFunction,
  ca as ProposalRewardStatus,
  ua as ProposalStatus,
  p4 as SnsWasmCanister,
  Ee as StakeNeuronError,
  E2 as SubAccount,
  sa as Topic,
  _3 as TransferError,
  k3 as TxCreatedInFutureError,
  V2 as TxDuplicateError,
  v3 as TxTooOldError,
  z as UnrecognizedTypeError,
  v2 as UnsupportedValueError,
  da as Vote,
  no as accountIdentifierFromBytes,
  to as accountIdentifierToBytes,
  xn as checkAccountId,
  N3 as ineligibleNeurons,
  oe as mapTransferError,
  ae2 as mapTransferProtoError,
  oo as principalToAccountIdentifier,
  J2 as votableNeurons,
  K2 as votedNeurons
};
/*! Bundled license information:

@dfinity/nns/dist/esm/chunk-4SFQPNVV.js:
  (*! Bundled license information:
  
  @noble/hashes/esm/utils.js:
    (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
  *)

@dfinity/nns/dist/esm/chunk-V7YCXQVA.js:
  (*! Bundled license information:
  
  ieee754/index.js:
    (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  
  buffer/index.js:
    (*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     *)
  *)
*/
//# sourceMappingURL=@dfinity_nns.js.map
